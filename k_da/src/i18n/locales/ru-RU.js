// Russian (RU) locale
// Auto-generated from 04-app-code.js

export const ruRU = {
    banner: {
      large: `
 ███       █████   ████    ███████    ██████████     █████████
   ███      ███   ███   ███     ███  ███    ███   ███     ███
    ███   ███  ███    ███     ███ ███   ███ ███    ███
      ███ ███████    ███      ███ ███    ███ ███████████████
     ███  ███ ███   ███      ███ ███    ███ ███     ███
   ███    ███  ███  ███     ███  ███    ███  ███    ███
 ███      █████  ████  ███████   ██████████   █████   █████

`,
      medium: `
 ███       █████   ████    ███████    ██████████     █████████
   ███      ███   ███   ███     ███  ███    ███   ███     ███
    ███   ███  ███    ███     ███ ███   ███ ███    ███
      ███ ███████    ███      ███ ███    ███ ███████████████
     ███  ███ ███   ███      ███ ███    ███ ███     ███
   ███    ███  ███  ███     ███  ███    ███  ███    ███
 ███      █████  ████  ███████   ██████████   █████   █████

`,
      small: `
 ███       █████   ████
   ███      ███   ███
    ███   ███  ███
      ███ ███████
     ███  ███ ███
   ███    ███  ███
 ███      █████  ████

`,
    },
    help: {
      basics: 'Основы:',
      addContext:
        'Добавление контекста',
      addContextDescription:
        'Используйте {at}, чтобы указать файлы для контекста (например, {example}), чтобы выбрать определенные файлы или папки',
      shellMode: 'Режим оболочки',
      shellModeDescription:
        'Выполняйте команды оболочки через {exclamation} (например, {example}) или используйте естественный язык (например, {naturalLanguage})',
      shellModeNaturalLanguageExample:
        'запустить сервер',
      commands: 'Команды:',
      shellCommand:
        'команда оболочки',
      shortcuts:
        'Горячие клавиши:',
      jumpWords:
        'Перемещение по словам во вводимом тексте',
      quitApp:
        'Выйти из приложения',
      newLine: 'Новая строка',
      newLineLinux:
        'Новая строка (Alt+Enter работает в некоторых дистрибутивах Linux)',
      clearScreen:
        'Очистить экран',
      openEditor:
        'Открыть ввод во внешнем редакторе',
      toggleYolo:
        'Переключить режим YOLO',
      sendMessage:
        'Отправить сообщение',
      cancelOperation:
        'Отменить операцию',
      autoAcceptEdits:
        'Переключить автоматическое применение правок',
      cycleHistory:
        'Переключение по истории запросов',
      fullList:
        'Полный список горячих клавиш смотрите в {file}',
    },
    commandMessages: {
      docs: {
        openingInBrowser:
          'Открытие документации в вашем браузере: {url}',
        openInBrowserMessage: `Пожалуйста, откройте следующий URL-адрес в браузере для просмотра документации:
{url}

Если браузер не открывается автоматически, скопируйте и вставьте эту ссылку для доступа к документации: {url}`,
      },
      init: {
        configNotAvailable:
          'Конфигурация недоступна.',
        fileAlreadyExists:
          'Файл KODA.md уже существует в этой директории. Изменения не внесены.',
        fileCreated:
          'Пустой файл KODA.md создан. Выполняется анализ проекта для заполнения.',
      },
      ide: {
        notSupported:
          'Интеграция с IDE не поддерживается в вашей текущей среде. Чтобы использовать эту функцию, запустите Koda CLI в одной из поддерживаемых IDE: {supportedList}',
        noInstaller:
          "Нет доступного установщика для {ideName}. Установите расширение '{extensionName}' вручную из маркета.",
        installing:
          'Установка компаньона IDE...',
        connected: 'Подключено к {ideName}',
        connecting: 'Подключение...',
        disconnected: 'Отключено',
        disconnectedWithDetails:
          'Отключено: {details}',
        openFilesTitle:
          'Открытые файлы:',
        fileLimitNote:
          '(Примечание: список файлов ограничен количеством недавно открытых файлов в вашей рабочей области и включает только локальные файлы на диске)',
        openingBrowser:
          'Открываю браузер для установки компаньона IDE: {url}',
        browserOpened:
          'Браузер успешно открыт. Пожалуйста, следуйте инструкциям по установке на сайте.',
        openUrlError:
          'Не удалось открыть URL в браузере: ',
      },
      vim: {
        enteredMode:
          'Вошли в режим Vim. Выполните /vim снова для выхода.',
        exitedMode:
          'Вышли из режима Vim.',
      },
    },
    statsDisplay: {
      sessionStats:
        'Статистика сессии',
      interactionSummary:
        'Сводка взаимодействия',
      sessionId: 'ID сессии:',
      toolCalls:
        'Вызовы инструментов:',
      successRate: 'Успешность:',
      userAgreement:
        'Согласие пользователя:',
      userAgreementReviewed: '({count} оценено)',
      performance:
        'Производительность',
      wallTime: 'Общее время:',
      agentActive:
        'Активность агента:',
      apiTime: 'API-время:',
      toolTime:
        'Время инструментов:',
      modelUsage:
        'Использование моделей',
      requests: 'Запросы',
      inputTokens:
        'Входные токены',
      outputTokens:
        'Выходные токены',
      savingsHighlight: 'Экономия:',
      savingsDetail:
        '{tokens} ({percent}%) входных токенов были обслужены из кэша, снижая затраты.',
      tipFullStats:
        'Подсказка: Полную разбивку токенов можно получить командой {command}.',
    },
    sessionSummary: {
      poweringDown:
        'Агент завершает работу. До свидания!',
    },
    settings: {
      theme: {
        label: 'Тема',
        description:
          'Цветовая тема интерфейса.',
      },
      customThemes: {
        label:
          'Пользовательские темы',
        description:
          'Определения пользовательских тем.',
      },
      hideWindowTitle: {
        label:
          'Скрыть заголовок окна',
        description:
          'Скрыть строку заголовка окна',
      },
      hideTips: {
        label:
          'Скрыть подсказки',
        description:
          'Скрыть полезные подсказки в интерфейсе',
      },
      hideBanner: {
        label: 'Скрыть баннер',
        description:
          'Скрыть баннер приложения',
      },
      showMemoryUsage: {
        label:
          'Показывать использование памяти',
        description:
          'Отображать информацию об использовании памяти в интерфейсе',
      },
      usageStatisticsEnabled: {
        label:
          'Включить статистику использования',
        description:
          'Включить сбор статистики использования',
      },
      autoConfigureMaxOldSpaceSize: {
        label:
          'Автонастройка Max Old Space Size',
        description:
          'Автоматически настраивать лимиты памяти Node.js',
      },
      preferredEditor: {
        label:
          'Предпочитаемый редактор',
        description:
          'Предпочитаемый редактор для открытия файлов.',
      },
      maxSessionTurns: {
        label:
          'Макс. число ходов сессии',
        description:
          'Максимальное число ходов пользователя/модели/инструментов, сохраняемых в сессии.',
      },
      memoryImportFormat: {
        label:
          'Формат импорта памяти',
        description:
          'Формат, используемый при импорте памяти.',
      },
      memoryDiscoveryMaxDirs: {
        label:
          'Макс. число директорий для поиска памяти',
        description:
          'Максимальное число директорий для поиска памяти.',
      },
      contextFileName: {
        label:
          'Имя файла контекста',
        description:
          'Имя файла контекста.',
      },
      vimMode: {
        label: 'Режим Vim',
        description:
          'Включить раскладку клавиш Vim',
      },
      ideMode: {
        label: 'Режим IDE',
        description:
          'Включить режим интеграции с IDE',
      },
      accessibility: {
        label:
          'Специальные возможности',
        description:
          'Настройки специальных возможностей.',
        disableLoadingPhrases: {
          label:
            'Отключить фразы загрузки',
          description:
            'Отключить фразы загрузки для улучшения доступности',
        },
      },
      checkpointing: {
        label:
          'Контрольные точки',
        description:
          'Настройки контрольных точек сессии.',
        enabled: {
          label:
            'Включить контрольные точки',
          description:
            'Включить контрольные точки сессии для восстановления',
        },
      },
      fileFiltering: {
        label:
          'Фильтрация файлов',
        description:
          'Настройки фильтрации файлов с учетом git.',
        respectGitIgnore: {
          label: 'Учитывать .gitignore',
          description:
            'Учитывать файлы .gitignore при поиске',
        },
        respectGeminiIgnore: {
          label: 'Учитывать .kodaignore',
          description:
            'Учитывать файлы .kodaignore при поиске',
        },
        enableRecursiveFileSearch: {
          label:
            'Включить рекурсивный поиск файлов',
          description:
            'Включить функцию рекурсивного поиска файлов',
        },
      },
      disableAutoUpdate: {
        label:
          'Отключить автообновление',
        description:
          'Отключить автоматические обновления',
      },
      selectedAuthType: {
        label:
          'Выбранный тип аутентификации',
        description:
          'Текущий выбранный тип аутентификации.',
      },
      useExternalAuth: {
        label:
          'Использовать внешнюю аутентификацию',
        description:
          'Использовать ли внешний поток аутентификации.',
      },
      sandbox: {
        label: 'Песочница',
        description:
          'Среда выполнения в песочнице (может быть булевым значением или путем).',
      },
      coreTools: {
        label:
          'Базовые инструменты',
        description:
          'Пути к определениям базовых инструментов.',
      },
      excludeTools: {
        label:
          'Исключить инструменты',
        description:
          'Имена инструментов для исключения из обнаружения.',
      },
      toolDiscoveryCommand: {
        label:
          'Команда обнаружения инструментов',
        description:
          'Команда для запуска обнаружения инструментов.',
      },
      toolCallCommand: {
        label:
          'Команда вызова инструмента',
        description:
          'Команда для запуска вызова инструментов.',
      },
      mcpServerCommand: {
        label:
          'Команда сервера MCP',
        description:
          'Команда для запуска сервера MCP.',
      },
      mcpServers: {
        label: 'Серверы MCP',
        description:
          'Конфигурация серверов MCP.',
      },
      allowMCPServers: {
        label:
          'Разрешенные серверы MCP',
        description:
          'Список (allowlist) серверов MCP, которые разрешены.',
      },
      excludeMCPServers: {
        label:
          'Исключенные серверы MCP',
        description:
          'Список (blocklist) серверов MCP, которые исключены.',
      },
      telemetry: {
        label: 'Телеметрия',
        description:
          'Конфигурация телеметрии.',
      },
      bugCommand: {
        label:
          'Команда отчета об ошибке',
        description:
          'Конфигурация команды отправки отчета об ошибке.',
      },
      summarizeToolOutput: {
        label:
          'Суммировать вывод инструментов',
        description:
          'Настройки суммирования вывода инструментов.',
      },
      dnsResolutionOrder: {
        label:
          'Порядок разрешения DNS',
        description:
          'Порядок разрешения DNS.',
      },
      excludedProjectEnvVars: {
        label:
          'Исключенные переменные окружения проекта',
        description:
          'Переменные окружения, исключаемые из контекста проекта.',
      },
      disableUpdateNag: {
        label:
          'Отключить напоминания об обновлении',
        description:
          'Отключить уведомления о необходимости обновления.',
      },
      includeDirectories: {
        label:
          'Включить директории',
        description:
          'Дополнительные директории, включаемые в контекст рабочей области.',
      },
      loadMemoryFromIncludeDirectories: {
        label:
          'Загружать память из включенных директорий',
        description:
          'Загружать ли файлы памяти из включенных директорий.',
      },
      model: {
        label: 'Модель',
        description:
          'Модель Koda для диалогов.',
      },
      hasSeenIdeIntegrationNudge: {
        label:
          'Подсказка интеграции с IDE показана',
        description:
          'Показывалась ли пользователю подсказка об интеграции IDE.',
      },
      folderTrustFeature: {
        label:
          'Функция доверия к папкам',
        description:
          'Включить функцию доверия к папкам для повышения безопасности.',
      },
      folderTrust: {
        label: 'Доверие к папке',
        description:
          'Отслеживать, включено ли доверие к папке.',
      },
      chatCompression: {
        label: 'Сжатие чата',
        description:
          'Настройки сжатия чата.',
      },
      showLineNumbers: {
        label:
          'Показывать номера строк',
        description:
          'Показывать номера строк в чате.',
      },
      language: {
        label: 'Язык',
        description:
          'Язык пользовательского интерфейса.',
      },
    },
    languageSetting: {
      selectLanguage: 'Выберите язык:',
      english: 'Английский',
      russian: 'Русский',
      pressToSelect:
        'Нажмите {key} для выбора',
      pressEscToCancel:
        'Нажмите ESC для отмены',
      pressEnterToChange:
        'Нажмите Enter для изменения',
    },
    authDialog: {
      loginWithGithub: 'Войти через GitHub',
      continueWithoutAuth:
        'Продолжить без аутентификации',
      getTitle: 'Начало работы',
      authQuestion:
        'Как вы хотите аутентифицироваться?',
      useEnterToSelect:
        '(Используйте Enter для выбора)',
      existingApiKeyDetected:
        'Обнаружен существующий API-ключ (KODA_API_KEY)',
      authenticateLater:
        'Вы можете аутентифицироваться позже через меню.',
      termsOfService:
        'Условия использования и уведомление о конфиденциальности для Koda CLI',
    },
    authInProgress: {
      waitingMessage:
        'Ожидание аутентификации... (Нажмите ESC или CTRL+C для отмены)',
      openUrlMessage: 'Открыть: ',
      codeMessage: 'Код: ',
      timeoutMessage:
        'Время ожидания аутентификации истекло. Попробуйте еще раз.',
    },
    contextSummary: {
      using: 'Используется:',
      openFile: 'открытый файл',
      openFiles: 'открытых файла',
      contextFile:
        'файл контекста',
      contextFiles:
        'файла контекста',
      mcpServer: 'сервер MCP',
      mcpServers: 'сервера MCP',
      blockedMcpServer:
        'Заблокированный сервер MCP',
      blockedMcpServers:
        'Заблокированных сервера MCP',
      viewOpenFiles:
        'ctrl+g для просмотра',
      viewMcp: 'ctrl+t для просмотра',
      toggleMcp:
        'ctrl+t для переключения',
    },
    loading: {
      activity: {
        processingResponse:
          'Обрабатываю ваш запрос...',
        awaitingUserConfirmation:
          'Ожидаю вашего подтверждения...',
        executing: {
          withDescription:
            'Выполняю {tool} - {description}',
          withoutDescription: 'Выполняю {tool}',
        },
        validating: {
          withDescription:
            'Проверяю параметры {tool} - {description}',
          withoutDescription:
            'Проверяю параметры {tool}',
        },
        scheduled: {
          withDescription: 'Готовлю {tool} - {description}',
          withoutDescription: 'Готовлю {tool}',
        },
        awaitingApproval: {
          withDescription:
            'Нужно подтверждение для {tool} - {description}',
          withoutDescription:
            'Нужно подтверждение для {tool}',
        },
        success: {
          withDescription:
            'Завершил {tool} - {description}',
          withoutDescription: 'Завершил {tool}',
        },
        error: {
          withDescription: 'Ошибка в {tool} - {description}',
          withoutDescription: 'Ошибка в {tool}',
        },
        cancelled: {
          withDescription: 'Отменил {tool} - {description}',
          withoutDescription: 'Отменил {tool}',
        },
        tool: {
          read_file: {
            executing: {
              withDescription:
                'Читаю файл {description}',
              withoutDescription: 'Читаю файл',
            },
            success: {
              withDescription:
                'Прочитал файл {description}',
              withoutDescription:
                'Прочитал файл',
            },
          },
          read_many_files: {
            executing: {
              withDescription:
                'Читаю несколько файлов - {description}',
              withoutDescription:
                'Читаю несколько файлов',
            },
            success: {
              withDescription:
                'Прочитал несколько файлов - {description}',
              withoutDescription:
                'Прочитал несколько файлов',
            },
          },
          write_file: {
            awaiting_approval: {
              withDescription:
                'Нужно подтверждение на запись файла {description}',
              withoutDescription:
                'Нужно подтверждение на запись файла',
            },
            executing: {
              withDescription:
                'Записываю файл {description}',
              withoutDescription:
                'Записываю файл',
            },
            success: {
              withDescription:
                'Записал файл {description}',
              withoutDescription:
                'Записал файл',
            },
          },
          replace: {
            awaiting_approval: {
              withDescription:
                'Нужно подтверждение на обновление {description}',
              withoutDescription:
                'Нужно подтверждение на обновление файла',
            },
            executing: {
              withDescription: 'Обновляю {description}',
              withoutDescription:
                'Обновляю файл',
            },
            success: {
              withDescription: 'Обновил {description}',
              withoutDescription:
                'Обновил файл',
            },
          },
          edit: {
            awaiting_approval: {
              withDescription:
                'Нужно подтверждение на правку {description}',
              withoutDescription:
                'Нужно подтверждение на правку файла',
            },
            executing: {
              withDescription: 'Правлю {description}',
              withoutDescription: 'Правлю файл',
            },
            success: {
              withDescription: 'Исправил {description}',
              withoutDescription:
                'Исправил файл',
            },
          },
        },
      },
      cancelAndTimer: '(esc для отмены, {time})',
    },
    commandDescriptions: {
      about:
        'Показать информацию о версии',
      auth: 'Изменить метод аутентификации',
      chat: 'Управление историей разговоров',
      chatList:
        'Список сохраненных контрольных точек разговора',
      chatSave:
        'Сохранить текущий разговор как контрольную точку. Использование: /chat save <тег>',
      chatResume:
        'Возобновить контрольную точку разговора. Использование: /chat resume <тег>',
      chatDelete:
        'Удалить контрольную точку разговора. Использование: /chat delete <тег>',
      clear:
        'Очистить экран и историю разговоров',
      compress:
        'Сжимает контекст, заменяя его резюме',
      alreadyCompressing:
        'Вы уже сжимаете контекст, подождите пока он завершится',
      copy: 'Скопировать последний результат или фрагмент кода в буфер обмена',
      corgi:
        'Переключает режим корги',
      directory:
        'Управление каталогами рабочей области',
      directoryAdd:
        'Добавить каталоги в рабочую область. Используйте запятую для разделения нескольких путей',
      directoryShow:
        'Показать все каталоги в рабочей области',
      docs: 'Открыть документацию в браузере',
      editor:
        'Установить предпочтения внешнего редактора',
      extensions:
        'Список активных расширений',
      help: 'Справка по koda-cli',
      ide: 'Управление интеграцией IDE',
      ideStatus:
        'Проверить статус интеграции IDE',
      ideInstall:
        'Установить необходимый компаньон IDE для {ideName}',
      ideEnable:
        'Включить интеграцию IDE',
      ideDisable:
        'Отключить интеграцию IDE',
      init: 'Анализирует проект и создает индивидуальный файл KODA.md',
      memory:
        'Команды для взаимодействия с памятью',
      memoryShow:
        'Показать текущее содержимое памяти',
      memoryAdd:
        'Добавить содержимое в память',
      memoryRefresh:
        'Обновить память из источника',
      mcp: 'Список настроенных серверов и инструментов MCP',
      mcpAuth:
        'Аутентификация с сервером MCP с поддержкой OAuth',
      mcpRefresh:
        'Обновить список серверов и инструментов MCP',
      mcpConfigNotLoaded:
        'Конфигурация не загружена.',
      mcpToolRegistryError:
        'Не удалось получить реестр инструментов.',
      mcpNoServersConfigured:
        'Серверы MCP не настроены.',
      mcpServersStarting:
        'Серверы MCP запускаются ({count} инициализируется)...',
      mcpServersStartingNote:
        'Примечание: первый запуск может занять больше времени. Доступность инструментов обновится автоматически.',
      mcpConfiguredServersTitle:
        'Настроенные серверы MCP:',
      mcpStatusStarting:
        'Запуск... (первый запуск может занять больше времени)',
      mcpStatusDisconnected: 'Отключено',
      mcpStatusReady: 'Готов',
      mcpAuthExpired: '(OAuth токен истек)',
      mcpAuthAuthenticated:
        '(OAuth аутентификация пройдена)',
      mcpAuthNotAuthenticated:
        '(OAuth аутентификация не пройдена)',
      mcpToolSingular: 'инструмент',
      mcpToolPlural: 'инструменты',
      mcpPromptSingular: 'подсказка',
      mcpPromptPlural: 'подсказки',
      mcpZeroTools: '(0 инструментов)',
      mcpToolsLoading:
        '(инструменты и подсказки появятся, когда будут готовы)',
      mcpToolsCached:
        '({count} инструментов в кэше)',
      mcpToolsTitle: 'Инструменты:',
      mcpParametersTitle: 'Параметры:',
      mcpPromptsTitle: 'Подсказки:',
      mcpNoToolsOrPrompts:
        'Нет доступных инструментов или подсказок',
      mcpNoToolsAvailable:
        'Нет доступных инструментов',
      mcpAuthHint:
        '(введите: "/mcp auth {serverName}" для аутентификации этого сервера)',
      mcpStatusBlocked: 'Заблокирован',
      mcpTipsTitle: '\u{1F4A1} Подсказки:',
      mcpTipsDesc:
        '  • Используйте {command} для отображения описаний серверов и инструментов',
      mcpTipsSchema:
        '  • Используйте {command} для отображения схем параметров инструментов',
      mcpTipsNoDesc:
        '  • Используйте {command} для скрытия описаний',
      mcpTipsAuth:
        '  • Используйте {command} для аутентификации с серверами, поддерживающими OAuth',
      mcpTipsToggle:
        '  • Нажмите {command} для переключения отображения описаний инструментов',
      mcpNoOauthServers:
        'Нет серверов MCP, настроенных с аутентификацией OAuth.',
      mcpOAuthServersList: `Серверы MCP с аутентификацией OAuth:
{serverList}

Используйте /mcp auth <имя-сервера> для аутентификации.`,
      mcpServerNotFound:
        "Сервер MCP '{serverName}' не найден.",
      mcpAuthStarting:
        "Запуск OAuth аутентификации для сервера MCP '{serverName}'...",
      mcpAuthSuccess:
        "✅ Успешно пройдена аутентификация с сервером MCP '{serverName}'!",
      mcpAuthRediscovering:
        "Повторное обнаружение инструментов из '{serverName}'...",
      mcpAuthRefreshSuccess:
        "Успешно пройдена аутентификация и обновлены инструменты для '{serverName}'.",
      mcpAuthFailure:
        "Не удалось пройти аутентификацию с сервером MCP '{serverName}': {error}",
      mcpRefreshing:
        'Обновление серверов и инструментов MCP...',
      privacy:
        'Показать уведомление о конфиденциальности',
      quit: 'Выйти из cli',
      restore:
        'Восстановить предыдущую версию файла. Использование: /restore <путь_к_файлу>',
      restoreCommand: {
        noCheckpointDir:
          'Не удалось определить путь к директории .kodacli.',
        noRestorableCalls:
          'Не найдено инструментов для восстановления.',
        availableCalls:
          'Доступные вызовы инструментов для восстановления:\\n\\n{fileList}',
        fileNotFound:
          'Файл не найден: {fileName}',
        loadHistoryNotAvailable:
          'Функция loadHistory недоступна.',
        projectRestored:
          'Проект восстановлен до состояния перед вызовом инструмента.',
        readError:
          'Не удалось прочитать вызовы инструментов для восстановления. Ошибка: {error}',
      },
      settings:
        'Просмотр и редактирование настроек Koda CLI',
      setupGithub: 'Настроить GitHub Actions',
      stats:
        'Проверить статистику сессии',
      statsModel:
        'Показать статистику использования по моделям',
      statsTools:
        'Показать статистику использования по инструментам',
      theme: 'Изменить тему',
      tools:
        'Список доступных инструментов Koda CLI',
      vim: 'Включить/выключить режим vim',
      model: 'Выбрать модель',
      terminalSetup:
        'Настроить терминал',
      bug: 'Сообщить об ошибке или проблеме',
    },
    bugCommand: {
      browserInstruction: `Открывается отчет об ошибке в вашем браузере по умолчанию...
`,
      bugReportDetails:
        'Сведения об ошибке:',
      openUrlError:
        'Не удалось открыть URL-адрес в браузере: ',
      telegramCommunity:
        'Сообщество в Telegram:',
    },
    commandPrompts: {
      init: `
Ты — ИИ-агент, который приносит возможности Koda прямо в терминал. Твоя задача — проанализировать текущую директорию и сгенерировать подробный файл KODA.md, который будет использоваться как инструкционный контекст для будущих взаимодействий.

**Требование языка:** Весь анализ и финальный файл должны быть полностью написаны на русском языке — используйте русские заголовки, формулировки и термины.

**Процесс анализа:**

1.  **Первичное исследование:**
    *   Начни с вывода списка файлов и директорий, чтобы получить общее представление о структуре.
    *   Прочитай файл README (например, \`README.md\`, \`README.txt\`), если он есть. Это часто лучший старт.

2.  **Итеративное погружение (до 10 файлов):**
    *   По итогам первичных наблюдений выбери несколько наиболее важных файлов (например, конфигурационные файлы, основные исходники, документацию).
    *   Прочитай их. По мере того как ты узнаешь больше, уточняй понимание и решай, какие файлы читать дальше. Не нужно выбирать все 10 сразу — пусть открытия направляют дальнейшие шаги.

3.  **Определи тип проекта:**
    *   **Проект с кодом:** Ищи признаки вроде \`package.json\`, \`requirements.txt\`, \`pom.xml\`, \`go.mod\`, \`Cargo.toml\`, \`build.gradle\` или директории \`src\`. Если они есть, скорее всего это программный проект.
    *   **Проект без кода:** Если кодовых файлов нет, каталог может содержать документацию, исследования, заметки или другое содержимое.

**Создание KODA.md:**

**Для проекта с кодом:**

*   **Обзор проекта:** Кратко опиши назначение проекта, основные технологии и архитектуру.
*   **Сборка и запуск:** Зафиксируй ключевые команды для сборки, запуска и тестирования проекта. Сделай выводы по прочитанным файлам (например, раздел \`scripts\` в \`package.json\`, \`Makefile\` и т.п.). Если явных команд нет, добавь заглушку с TODO.
*   **Правила разработки:** Опиши стиль кодирования, практики тестирования или правила контрибуции, которые можно вывести из кодовой базы.

**Для проекта без кода:**

*   **Обзор каталога:** Опиши назначение и содержимое директории. Для чего она? Какие типы материалов хранит?
*   **Ключевые файлы:** Перечисли важные файлы и кратко поясни, что в них находится.
*   **Использование:** Объясни, как предполагается использовать содержимое каталога.

**Финальный результат:**

Запиши готовый текст в файл \`KODA.md\`. Выход должен быть корректно оформленным Markdown.
Не используй английский язык ни в каких разделах.
`,
    },
    toolDescriptions: {
      search_file_content:
        'Выполняет поиск по регулярному выражению в содержимом файлов в указанной директории (или текущей директории). Может фильтровать файлы по glob-шаблону. Возвращает строки, содержащие совпадения, вместе с путями к файлам и номерами строк.',
      list_directory:
        'Выводит имена файлов и подкаталогов непосредственно в указанном каталоге. Может игнорировать записи, соответствующие заданным glob-шаблонам.',
      glob: 'Эффективно находит файлы, соответствующие определенным glob-шаблонам (например, `src/**/*.ts`, `**/*.md`), возвращая абсолютные пути, отсортированные по времени модификации (новые первыми). Идеально подходит для быстрого поиска файлов по имени или структуре пути, особенно в больших кодовых базах.',
      google_web_search:
        'Выполняет веб-поиск с помощью API Serper и возвращает лучшие органические результаты.',
      save_memory: `Сохраняет конкретный фрагмент информации или факт в вашу долговременную память.

Используйте этот инструмент:

- Когда пользователь явно просит вас что-то запомнить (например, "Запомни, что я люблю пиццу с ананасом", "Пожалуйста, сохраните: имя моего кота - Васька").
- Когда пользователь сообщает ясный, краткий факт о себе, своих предпочтениях или своей среде, который, кажется, важен для сохранения в будущих взаимодействиях, чтобы обеспечить более персонализированную и эффективную помощь.

НЕ используйте этот инструмент:

- Для запоминания контекста разговора, который актуален только для текущей сессии.
- Для сохранения длинного, сложного или развернутого текста. Факт должен быть относительно коротким и по делу.
- Если вы не уверены, стоит ли информацию запоминать на долгосрочной основе. Если сомневаетесь, можете спросить пользователя: "Мне запомнить это для вас?"

## Параметры

- \`fact\` (string, required): Конкретный факт или фрагмент информации для запоминания. Должно быть ясным, самодостаточным утверждением. Например, если пользователь говорит "Мой любимый цвет - синий", то факт будет "Мой любимый цвет - синий".`,
      run_shell_command:
        'Этот инструмент выполняет заданную команду оболочки как `bash -c <command>`. Команда может запускать фоновые процессы с помощью `&`. Команда выполняется как подпроцесс, который ведет свою собственную группу процессов. Группу процессов можно завершить с помощью `kill -- -PGID` или отправить сигнал `kill -s SIGNAL -- -PGID`.\n\n      Возвращается следующая информация:\n\n      Команда: Выполненная команда.\n      Каталог: Каталог (относительно корня проекта), где была выполнена команда, или `(root)`.\n      Stdout: Вывод в поток stdout. Может быть `(пусто)` или частичным при ошибке и для любых непрочитанных фоновых процессов.\n      Stderr: Вывод в поток stderr. Может быть `(пусто)` или частичным при ошибке и для любых непрочитанных фоновых процессов.',
    },
    tips: {
      title:
        'Советы для начала работы:',
      tip1: '1. Задавайте вопросы, редактируйте файлы или запускайте команды',
      tip2: '2. Будьте конкретны для получения наилучших результатов',
      tip3: '3. Создайте файлы {fileName} для настройки взаимодействия с Koda',
      tip4: '4. {command} для получения дополнительной информации',
      tip3noFile:
        '3. {command} для получения дополнительной информации',
    },
    startupWarnings: {
      homeDirectory: {
        message:
          'Вы запускаете Koda CLI в вашей домашней директории. Рекомендуется запускать в директории конкретного проекта.',
      },
      rootDirectory: {
        message:
          'Предупреждение: Вы запускаете Koda CLI в корневой директории. Вся ваша структура папок будет использоваться для контекста. Настоятельно рекомендуется запускать в директории конкретного проекта.',
      },
      fileSystemError: {
        message:
          'Не удалось проверить текущую директорию из-за ошибки файловой системы.',
      },
    },
    app: {
      context: {
        contextLeft:
          '{percentLeft}% контекста осталось',
      },
      requestCancelled:
        'Запрос отменен.',
      docs: { seeDocs: 'см. /docs' },
      settings: {
        title: 'Настройки',
        applyTo: 'Применить к',
        enterSelectTabFocus:
          '(Используйте Enter для выбора, Tab для смены фокуса)',
        restartRequired:
          'Чтобы увидеть изменения, необходимо перезапустить Koda CLI. Нажмите r для выхода и применения изменений.',
      },
      about: {
        title: 'О Koda CLI',
        cliVersion: 'Версия CLI',
        gitCommit: 'Git коммит',
        model: 'Модель',
        sandbox: 'Песочница',
        os: 'ОС',
        authMethod:
          'Метод аутентификации',
        gcpProject: 'Проект GCP',
      },
      compression: {
        compressing:
          'Сжатие истории чата',
        compressed:
          'История чата сжата с {original} до {new} токенов.',
      },
      chat: {
        noCheckpoints:
          'Не найдено сохраненных контрольных точек разговора.',
        listTitle:
          'Список сохраненных разговоров:',
        savedOn: 'сохранен',
        noteNewestLast:
          'Примечание: Новые в конце, старые в начале',
        missingTag:
          'Отсутствует тег. Использование: /chat save <тег>',
        conversationSaved:
          'Контрольная точка разговора сохранена с тегом: {tag}.',
        noConversation:
          'Не найдено разговора для сохранения.',
        noCheckpoint:
          'Не найдена контрольная точка с тегом: {tag}.',
        overwritePrompt:
          'Контрольная точка с тегом {tag} уже существует. Перезаписать её?',
      },
      copy: {
        noOutput:
          'Нет вывода в истории',
        copied:
          'Последний вывод скопирован в буфер обмена',
        failed:
          'Не удалось скопировать в буфер обмена.',
        noText:
          'Последний вывод ИИ не содержит текста для копирования.',
      },
      directory: {
        configNotAvailable:
          'Конфигурация недоступна.',
        providePath:
          'Пожалуйста, укажите хотя бы один путь для добавления.',
        notSupported:
          'Команда /directory add не поддерживается в ограничительных профилях песочницы. Вместо этого используйте --include-directories при запуске сессии.',
        successfullyAddedFiles: `Успешно добавлены файлы KODA.md из следующих директорий, если они есть:
- {directories}`,
        successfullyAdded: `Успешно добавлены директории:
- {directories}`,
        currentDirectories: `Текущие директории рабочей области:
{directories}`,
      },
      tools: {
        noRegistry:
          'Не удалось получить реестр инструментов.',
        available: `Доступные инструменты Koda CLI:

`,
        noTools: `  Нет доступных инструментов
`,
      },
      editorSettings: {
        title:
          'Выберите редактор',
        applyTo: 'Применить к',
        enterSelectTabFocus:
          '(Используйте Enter для выбора, Tab для смены фокуса)',
        supportedEditors:
          'В настоящее время поддерживаются следующие редакторы. Обратите внимание, что некоторые редакторы нельзя использовать в режиме песочницы.',
        preferredEditor:
          'Ваш предпочтительный редактор: ',
        none: 'Нет',
      },
      theme: {
        title: 'Выберите тему',
        applyTo: 'Применить к',
        preview:
          'Предварительный просмотр',
        enterSelectTabFocus:
          '(Используйте Enter для выбора, Tab для смены фокуса)',
      },
      stats: {
        modelStats:
          'Статистика моделей (для технарей)',
        toolStats:
          'Статистика инструментов (для технарей)',
        metric: 'Метрика',
        api: 'API',
        requests: 'Запросы',
        errors: 'Ошибки',
        avgLatency:
          'Средняя задержка',
        tokens: 'Токены',
        total: 'Всего',
        prompt: 'Промпт',
        cached: 'Кэшировано',
        thoughts: 'Размышления',
        tool: 'Инструмент',
        toolName:
          'Название инструмента',
        output: 'Вывод',
        calls: 'Вызовы',
        successRate:
          'Уровень успеха',
        avgDuration:
          'Средняя продолжительность',
        userDecisionSummary:
          'Сводка решений пользователя',
        totalReviewed:
          'Всего рассмотрено предложений',
        accepted: 'Принято',
        rejected: 'Отклонено',
        modified: 'Изменено',
        overallAgreementRate:
          'Общий уровень согласия',
        noApiCalls:
          'В этой сессии не было выполнено ни одного вызова API.',
        noToolCalls:
          'В этой сессии не было выполнено ни одного вызова инструмента.',
      },
      memory: {
        refreshing:
          'Обновляю иерархическую память (KODA.md или другие файлы контекста)...',
        refreshSuccess:
          'Память успешно обновлена. Загружено {charCount} символов из {fileCount} файла(ов).',
        refreshSuccessEmpty:
          'Память успешно обновлена. Содержимое не найдено.',
        refreshError:
          'Ошибка при обновлении памяти: {error}',
        empty:
          'Память сейчас пуста.',
        usage:
          'Использование: /memory add <текст для запоминания>',
        saving:
          'Попытка сохранить в память: "{text}"',
        refreshingFromSourceFiles:
          'Обновление памяти из исходных файлов...',
        refreshSuccessFromSourceFiles:
          'Память успешно обновлена. Загружено {characters} символов из {files} файла(ов).',
        showContent: `Текущее содержимое памяти из {fileCount} файла(ов):

---
{memoryContent}
---`,
        save: 'Сохранить в память',
        saveSuccess:
          'Хорошо, я запомнил: "{fact}"',
        saveModifiedSuccess:
          'Хорошо, я обновил файл памяти с вашими изменениями.',
        saveError:
          'Ошибка при сохранении памяти: {error}',
        validationNonEmpty:
          'Параметр "fact" должен быть непустой строкой.',
      },
      flashFallback: {
        proQuotaExceeded: `⚡ Переключаюсь с {currentModel} на {fallbackModel} до конца сессии: текущая модель временно недоступна.
⚡ Используйте /auth, чтобы настроить другой токен доступа и выбрать модель.`,
        freeQuotaExceeded: `⚡ Переключаюсь с {currentModel} на {fallbackModel} до конца сессии: текущая модель временно недоступна.
⚡ Используйте /auth, чтобы настроить другой токен доступа и выбрать модель.`,
        proGenericQuota: `⚡ Переключаюсь с {currentModel} на {fallbackModel} до конца сессии: текущая модель временно недоступна.
⚡ Используйте /auth, чтобы настроить другой токен доступа и выбрать модель.`,
        freeGenericQuota: `⚡ Переключаюсь с {currentModel} на {fallbackModel} до конца сессии: текущая модель временно недоступна.
⚡ Используйте /auth, чтобы настроить другой токен доступа и выбрать модель.`,
        proDefault: `⚡ Переключаюсь с {currentModel} на {fallbackModel} до конца сессии: текущая модель временно недоступна.
⚡ Используйте /auth, чтобы настроить другой токен доступа и выбрать модель.`,
        freeDefault: `⚡ Переключаюсь с {currentModel} на {fallbackModel} до конца сессии: текущая модель временно недоступна.
⚡ Используйте /auth, чтобы настроить другой токен доступа и выбрать модель.`,
      },
      trial: {
        footerLabel:
          'пробные запросы {used}{limitPart}',
        limitReached: `⚡ Вы израсходовали все пробные запросы Koda.
⚡ Запросы будут приостановлены до сброса лимита.
⚡ Настройте постоянный доступ через /auth или оформите тариф: ${process.env.KODA_SITE_URL || 'https://kodacode.ru'} `,
      },
      auth: {
        reauthRequired:
          'Требуется повторная аутентификация',
        timeout:
          'Время ожидания аутентификации истекло. Попробуйте еще раз.',
      },
      prompts: {
        pressCtrlCAgain:
          'Нажмите Ctrl+C еще раз, чтобы выйти.',
        pressCtrlDAgain:
          'Нажмите Ctrl+D еще раз, чтобы выйти.',
        pressEscAgain:
          'Нажмите Esc еще раз, чтобы очистить.',
      },
      extensions: {
        noActive:
          'Нет активных расширений.',
        activeTitle:
          'Активные расширения:',
      },
      placeholders: {
        vim: "  Нажмите 'i' для режима INSERT и 'Esc' для режима NORMAL.",
        default:
          '  Введите сообщение или @путь/к/файлу',
      },
      confirmation: { yes: 'Да', no: 'Нет' },
      toolConfirmation: {
        modifyInProgress:
          'Изменение в процессе: ',
        saveAndCloseExternalEditor:
          'Сохраните и закройте внешний редактор, чтобы продолжить',
        applyThisChange:
          'Применить это изменение?',
        yesAllowOnce:
          'Да, разрешить один раз',
        yesAllowAlways:
          'Да, разрешить всегда',
        noEsc: 'Нет (esc)',
        modifyWithExternalEditor:
          'Изменить во внешнем редакторе',
        noSuggestChanges:
          'Нет, предложить изменения (esc)',
        allowExecutionOf:
          "Разрешить выполнение: '{command}'?",
        doYouWantToProceed:
          'Вы хотите продолжить?',
        urlsToFetch:
          'URL-адреса для получения:',
        allowExecutionOfMcpTool:
          'Разрешить выполнение инструмента MCP "{toolName}" с сервера "{serverName}"?',
        yesAlwaysAllowToolFromServer:
          'Да, всегда разрешать инструмент "{toolName}" с сервера "{serverName}"',
        yesAlwaysAllowAllToolsFromServer:
          'Да, всегда разрешать все инструменты с сервера "{serverName}"',
      },
      init: {
        error:
          'Ошибка инициализации: {error}',
        checkConfig:
          'Проверьте API-ключ и конфигурацию.',
      },
    },
  },
  nXt = { en: hDn, ru: ADn },
  NUe = class {
    currentLanguage;
    constructor(e) {
      let r = e?.language;
      r === 'en' || r === 'ru' ? (this.currentLanguage = r) : (this.currentLanguage = 'en');
    }
    setLanguage(e) {
      this.currentLanguage = e;
    }
    getLanguage() {
      return this.currentLanguage;
    }
    t(e, r) {
      let n = e.split('.'),
        i = nXt[this.currentLanguage],
        a = !0;
      for (let s of n)
        if (typeof i == 'object' && i !== null && s in i) i = i[s];
        else {
          a = !1;
          break;
        }
      if (a && typeof i == 'string') {
        if (r) {
          let s = i;
          for (let [o, l] of Object.entries(r)) s = s.replace(new RegExp(`{${o}}`, 'g'), String(l));
          return s;
        }
        return i;
      }
      if (this.currentLanguage !== 'en') {
        let s = nXt.en,
          o = !0;
        for (let l of n)
          if (typeof s == 'object' && s !== null && l in s) s = s[l];
          else {
            o = !1;
            break;
          }
        if (o && typeof s == 'string') {
          if (r) {
            let l = s;
            for (let [u, c] of Object.entries(r))
              l = l.replace(new RegExp(`{${u}}`, 'g'), String(c));
            return l;
          }
          return s;
        }
      }
      return e;
    }
  },
  Ie = new NUe();
function gDn(t) {
  let e = [];
  for (let r of t) Array.isArray(r) ? e.push(...r) : e.push(r);
  return e;
}
var aXt = (t, e, r, n, i, a, s, o, l, u, c, p, h, m) => {
  (0, Ps.useEffect)(() => {
    (async () => {
      try {
        let fe = await n.getToolRegistry(),
          Z = {},
          Q = [
            'search_file_content',
            'list_directory',
            'glob',
            'google_web_search',
            'save_memory',
            'run_shell_command',
          ];
        for (let ge of Q) {
          let xe = `toolDescriptions.${ge}`,
            He = Ie.t(xe);
          He && He !== xe && (Z[ge] = He);
        }
        Object.keys(Z).length > 0 && fe.updateToolDescriptions(Z);
      } catch (fe) {
        console.error('Error updating tool descriptions:', fe);
      }
    })();
  }, [n]);
  let [E, v] = (0, Ps.useState)(null),
    g = (0, Ps.useRef)(null),
    _ = (0, Ps.useRef)(!1),
    [S, b] = (0, Ps.useState)(!1),
    [I, R] = (0, Ps.useState)(null),
    [F, G] = jKt(null),
    U = (0, Ps.useRef)(new Set()),
    { startNewPrompt: M, getPromptCount: Y } = zg(),
    z = rme(),
    se = (0, Ps.useMemo)(() => {
      if (n.getProjectRoot()) return new xv(n.getProjectRoot());
    }, [n]),
    [j, N, H] = YKt(
      async ($) => {
        $.length > 0 && (r(IUe($), Date.now()), await ae($));
      },
      n,
      G,
      o,
      h
    ),
    ee = (0, Ps.useMemo)(() => (j.length ? IUe(j) : void 0), [j]),
    me = (0, Ps.useRef)(!1),
    Ae = (0, Ps.useCallback)(async ($) => {
      (b(!0), await $, b(!1));
    }, []),
    { handleShellCommand: X } = HKt(r, G, Ae, i, n, t),
    re = (0, Ps.useMemo)(
      () =>
        j.some(($) => $.status === 'awaiting_approval')
          ? 'waiting_for_confirmation'
          : S ||
              j.some(
                ($) =>
                  $.status === 'executing' ||
                  $.status === 'scheduled' ||
                  $.status === 'validating' ||
                  (($.status === 'success' || $.status === 'error' || $.status === 'cancelled') &&
                    !$.responseSubmittedToGemini)
              )
            ? 'responding'
            : 'idle',
      [S, j]
    ),
    de = (0, Ps.useMemo)(() => {
      let $ = [
        'awaiting_approval',
        'executing',
        'validating',
        'scheduled',
        'success',
        'error',
        'cancelled',
      ];
      for (let fe of $) {
        let Z = j.find((Q) => Q.status === fe);
        if (Z) return Z;
      }
      return null;
    }, [j]),
    ye = (0, Ps.useMemo)(() => {
      if (de) {
        let $ = de.tool?.displayName ?? de.request.name,
          Z = ('invocation' in de ? de.invocation : void 0)?.getDescription?.(),
          Q = typeof Z == 'string' ? Z.trim() : '',
          ge = Q.length > 0,
          He = {
            awaiting_approval: {
              withDescription: 'loading.activity.awaitingApproval.withDescription',
              withoutDescription: 'loading.activity.awaitingApproval.withoutDescription',
            },
            executing: {
              withDescription: 'loading.activity.executing.withDescription',
              withoutDescription: 'loading.activity.executing.withoutDescription',
            },
            validating: {
              withDescription: 'loading.activity.validating.withDescription',
              withoutDescription: 'loading.activity.validating.withoutDescription',
            },
            scheduled: {
              withDescription: 'loading.activity.scheduled.withDescription',
              withoutDescription: 'loading.activity.scheduled.withoutDescription',
            },
            success: {
              withDescription: 'loading.activity.success.withDescription',
              withoutDescription: 'loading.activity.success.withoutDescription',
            },
            error: {
              withDescription: 'loading.activity.error.withDescription',
              withoutDescription: 'loading.activity.error.withoutDescription',
            },
            cancelled: {
              withDescription: 'loading.activity.cancelled.withDescription',
              withoutDescription: 'loading.activity.cancelled.withoutDescription',
            },
          }[de.status];
        if (!He) return null;
        let mt = ge ? He.withDescription : He.withoutDescription,
          Tt = { tool: $ };
        ge && (Tt.description = Q);
        let jt = `loading.activity.tool.${de.request.name}.${de.status}`,
          ht = ge ? `${jt}.withDescription` : `${jt}.withoutDescription`,
          vt = Ie.t(ht, Tt);
        return vt !== ht ? vt : Ie.t(mt, Tt);
      }
      return re === 'responding'
        ? Ie.t('loading.activity.processingResponse')
        : re === 'waiting_for_confirmation'
          ? Ie.t('loading.activity.awaitingUserConfirmation')
          : null;
    }, [de, re]),
    he = (0, Ps.useCallback)(() => {
      re === 'responding' &&
        (_.current ||
          ((_.current = !0),
          g.current?.abort(),
          F.current && r(F.current, Date.now()),
          r({ type: 'info', text: Ie.t('app.requestCancelled') }, Date.now()),
          G(null),
          m(),
          b(!1)));
    }, [re, r, G, m, F]);
  ja(
    ($) => {
      $.name === 'escape' && he();
    },
    { isActive: re === 'responding' }
  );
  let be = (0, Ps.useCallback)(
      async ($, fe, Z, Q) => {
        if (_.current) return { queryToSend: null, shouldProceed: !1 };
        if (typeof $ == 'string' && $.trim().length === 0)
          return { queryToSend: null, shouldProceed: !1 };
        let ge = null;
        if (typeof $ == 'string') {
          let xe = $.trim();
          (GM(n, new SN(xe.length, Q, n.getContentGeneratorConfig()?.authType, xe)),
            i(`User query: '${xe}'`),
            await z?.logMessage(GQ.USER, xe));
          let He = await a(xe);
          if (He)
            switch (He.type) {
              case 'schedule_tool': {
                let { toolName: mt, toolArgs: Tt } = He,
                  jt = {
                    callId: `${mt}-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                    name: mt,
                    args: Tt,
                    isClientInitiated: !0,
                    prompt_id: Q,
                  };
                return (N([jt], Z), { queryToSend: null, shouldProceed: !1 });
              }
              case 'submit_prompt':
                return ((ge = He.content), { queryToSend: ge, shouldProceed: !0 });
              case 'handled':
                return { queryToSend: null, shouldProceed: !1 };
              default: {
                let mt = He;
                throw new Error(`Unhandled slash command result type: ${mt}`);
              }
            }
          if (s && X(xe, Z)) return { queryToSend: null, shouldProceed: !1 };
          if (LKt(xe)) {
            let mt = await GKt({
              query: xe,
              config: n,
              addItem: r,
              onDebugMessage: i,
              messageId: fe,
              signal: Z,
            });
            if (!mt.shouldProceed) return { queryToSend: null, shouldProceed: !1 };
            ge = mt.processedQuery;
          } else (r({ type: 'user', text: xe }, fe), (ge = xe));
        } else ge = $;
        return ge === null
          ? (i('Query processing resulted in null, not sending to Gemini.'),
            { queryToSend: null, shouldProceed: !1 })
          : { queryToSend: ge, shouldProceed: !0 };
      },
      [n, r, i, X, a, z, s, N]
    ),
    De = (0, Ps.useCallback)(
      ($, fe, Z) => {
        if (_.current) return '';
        let Q = fe + $;
        F.current?.type !== 'gemini' &&
          F.current?.type !== 'gemini_content' &&
          (F.current && r(F.current, Z), G({ type: 'gemini', text: '' }), (Q = $));
        let ge = $Kt(Q);
        if (ge === Q.length) G((xe) => ({ type: xe?.type, text: Q }));
        else {
          let xe = Q.substring(0, ge),
            He = Q.substring(ge);
          (r({ type: F.current?.type, text: xe }, Z),
            G({ type: 'gemini_content', text: He }),
            (Q = He));
        }
        return Q;
      },
      [r, F, G]
    ),
    ce = (0, Ps.useCallback)(
      ($) => {
        if (!_.current) {
          if (F.current) {
            if (F.current.type === 'tool_group') {
              let fe = F.current.tools.map((Q) =>
                  Q.status === 'Pending' || Q.status === 'Confirming' || Q.status === 'Executing'
                    ? { ...Q, status: 'Canceled' }
                    : Q
                ),
                Z = { ...F.current, tools: fe };
              r(Z, $);
            } else r(F.current, $);
            G(null);
          }
          (r({ type: 'info', text: 'User cancelled the request.' }, $), b(!1), R(null));
        }
      },
      [r, F, G, R]
    ),
    Ce = (0, Ps.useCallback)(
      ($, fe) => {
        (F.current && (r(F.current, fe), G(null)),
          r(
            {
              type: 'error',
              text: lk($.error, n.getContentGeneratorConfig()?.authType, void 0, n.getModel(), rd),
            },
            fe
          ),
          R(null));
      },
      [r, F, G, n, R]
    ),
    J = (0, Ps.useCallback)(
      ($, fe) => {
        let Z = $.value,
          ge = {
            [wf.FINISH_REASON_UNSPECIFIED]: void 0,
            [wf.STOP]: void 0,
            [wf.MAX_TOKENS]: 'Response truncated due to token limits.',
            [wf.SAFETY]: 'Response stopped due to safety reasons.',
            [wf.RECITATION]: 'Response stopped due to recitation policy.',
            [wf.LANGUAGE]: 'Response stopped due to unsupported language.',
            [wf.BLOCKLIST]: 'Response stopped due to forbidden terms.',
            [wf.PROHIBITED_CONTENT]: 'Response stopped due to prohibited content.',
            [wf.SPII]: 'Response stopped due to sensitive personally identifiable information.',
            [wf.OTHER]: 'Response stopped for other reasons.',
            [wf.MALFORMED_FUNCTION_CALL]: 'Response stopped due to malformed function call.',
            [wf.IMAGE_SAFETY]: 'Response stopped due to image safety violations.',
            [wf.UNEXPECTED_TOOL_CALL]: 'Response stopped due to unexpected tool call.',
          }[Z];
        ge && r({ type: 'info', text: `\u26A0\uFE0F  ${ge}` }, fe);
      },
      [r]
    ),
    te = (0, Ps.useCallback)(
      ($) =>
        r(
          {
            type: 'info',
            text: `IMPORTANT: This conversation approached the input token limit for ${n.getModel()}. A compressed context will be sent for future messages (compressed from: ${$?.originalTokenCount ?? 'unknown'} to ${$?.newTokenCount ?? 'unknown'} tokens).`,
          },
          Date.now()
        ),
      [r, n]
    ),
    ie = (0, Ps.useCallback)(
      () =>
        r(
          {
            type: 'info',
            text: `The session has reached the maximum number of turns: ${n.getMaxSessionTurns()}. Please update this limit in your setting.json file.`,
          },
          Date.now()
        ),
      [r, n]
    ),
    pe = (0, Ps.useCallback)(() => {
      r(
        {
          type: 'info',
          text: 'A potential loop was detected. This can happen due to repetitive tool calls or other model behavior. The request has been halted.',
        },
        Date.now()
      );
    }, [r]),
    ue = (0, Ps.useCallback)(
      async ($, fe, Z) => {
        let Q = '',
          ge = [];
        for await (let xe of $)
          switch (xe.type) {
            case Ls.Thought:
              R(xe.value);
              break;
            case Ls.Content:
              Q = De(xe.value, Q, fe);
              break;
            case Ls.ToolCallRequest:
              ge.push(xe.value);
              break;
            case Ls.UserCancelled:
              ce(fe);
              break;
            case Ls.Error:
              Ce(xe.value, fe);
              break;
            case Ls.ChatCompressed:
              te(xe.value);
              break;
            case Ls.ToolCallConfirmation:
            case Ls.ToolCallResponse:
              break;
            case Ls.MaxSessionTurns:
              ie();
              break;
            case Ls.Finished:
              J(xe, fe);
              break;
            case Ls.LoopDetected:
              me.current = !0;
              break;
            default:
              return xe;
          }
        return (ge.length > 0 && N(ge, Z), 0);
      },
      [De, ce, Ce, N, te, J, ie]
    ),
    ve = (0, Ps.useCallback)(
      async ($, fe, Z) => {
        if ((re === 'responding' || re === 'waiting_for_confirmation') && !fe?.isContinuation)
          return;
        let Q = Date.now();
        (fe?.isContinuation || (p(!1), n.setQuotaErrorOccurred(!1)),
          (g.current = new AbortController()));
        let ge = g.current.signal;
        ((_.current = !1), Z || (Z = n.getSessionId() + '########' + Y()));
        let { queryToSend: xe, shouldProceed: He } = await be($, Q, ge, Z);
        if (!(!He || xe === null)) {
          (fe?.isContinuation || (M(), R(null)), b(!0), v(null));
          try {
            let mt = t.sendMessageStream(xe, ge, Z);
            if ((await ue(mt, Q, ge)) === 1) return;
            (F.current && (r(F.current, Q), G(null)), me.current && ((me.current = !1), pe()));
          } catch (mt) {
            mt instanceof dS
              ? l()
              : (!Cs(mt) || mt.name !== 'AbortError') &&
                r(
                  {
                    type: 'error',
                    text: lk(
                      ir(mt) || 'Unknown error',
                      n.getContentGeneratorConfig()?.authType,
                      void 0,
                      n.getModel(),
                      rd
                    ),
                  },
                  Q
                );
          } finally {
            b(!1);
          }
        }
      },
      [re, p, be, ue, F, r, G, v, t, l, n, M, Y, pe]
    ),
    ae = (0, Ps.useCallback)(
      async ($) => {
        if (S) return;
        let fe = $.filter((jt) =>
            jt.status === 'success' || jt.status === 'error' || jt.status === 'cancelled'
              ? jt.response?.responseParts !== void 0
              : !1
          ),
          Z = fe.filter((jt) => jt.request.isClientInitiated);
        Z.length > 0 && H(Z.map((jt) => jt.request.callId));
        let Q = fe.filter(
          (jt) =>
            jt.request.name === 'save_memory' &&
            jt.status === 'success' &&
            !U.current.has(jt.request.callId)
        );
        Q.length > 0 && (u(), Q.forEach((jt) => U.current.add(jt.request.callId)));
        let ge = fe.filter((jt) => !jt.request.isClientInitiated);
        if (ge.length === 0) return;
        if (ge.every((jt) => jt.status === 'cancelled')) {
          if (t) {
            let ht = ge.flatMap((kt) => kt.response.responseParts),
              vt = [];
            for (let kt of ht)
              Array.isArray(kt)
                ? vt.push(...kt)
                : typeof kt == 'string'
                  ? vt.push({ text: kt })
                  : vt.push(kt);
            t.addHistory({ role: 'user', parts: vt });
          }
          let jt = ge.map((ht) => ht.request.callId);
          H(jt);
          return;
        }
        let He = ge.map((jt) => jt.response.responseParts),
          mt = ge.map((jt) => jt.request.callId),
          Tt = ge.map((jt) => jt.request.prompt_id);
        (H(mt), !c && ve(gDn(He), { isContinuation: !0 }, Tt[0]));
      },
      [S, ve, H, t, u, c]
    ),
    k = [F.current, ee].filter(($) => $ != null);
  return (
    (0, Ps.useEffect)(() => {
      (async () => {
        if (!n.getCheckpointingEnabled()) return;
        let fe = j.filter(
          (Z) =>
            (Z.request.name === 'replace' || Z.request.name === 'write_file') &&
            Z.status === 'awaiting_approval'
        );
        if (fe.length > 0) {
          let Z = n.getProjectTempDir() ? OUe.join(n.getProjectTempDir(), 'checkpoints') : void 0;
          if (!Z) return;
          try {
            await iXt.mkdir(Z, { recursive: !0 });
          } catch (Q) {
            if (!Cs(Q) || Q.code !== 'EEXIST') {
              i(`Failed to create checkpoint directory: ${ir(Q)}`);
              return;
            }
          }
          for (let Q of fe) {
            let ge = Q.request.args.file_path;
            if (!ge) {
              i(`Skipping restorable tool call due to missing file_path: ${Q.request.name}`);
              continue;
            }
            try {
              let xe = await se?.createFileSnapshot(`Snapshot for ${Q.request.name}`);
              if ((xe || (xe = await se?.getCurrentCommitHash()), !xe)) {
                i(`Failed to create snapshot for ${ge}. Skipping restorable tool call.`);
                continue;
              }
              let He = new Date().toISOString().replace(/:/g, '-').replace(/\./g, '_'),
                mt = Q.request.name,
                Tt = OUe.basename(ge),
                jt = `${He}-${Tt}-${mt}.json`,
                ht = await t?.getHistory(),
                vt = OUe.join(Z, jt);
              await iXt.writeFile(
                vt,
                JSON.stringify(
                  {
                    history: e,
                    clientHistory: ht,
                    toolCall: { name: Q.request.name, args: Q.request.args },
                    commitHash: xe,
                    filePath: ge,
                  },
                  null,
                  2
                )
              );
            } catch (xe) {
              i(`Failed to write restorable tool call file: ${ir(xe)}`);
            }
          }
        }
      })();
    }, [j, n, i, se, e, t]),
    {
      streamingState: re,
      submitQuery: ve,
      initError: E,
      pendingHistoryItems: k,
      thought: I,
      cancelOngoingRequest: he,
      activeActivity: ye,
    }
  );
};
var lb = qe(or(), 1);
var sXt = (t, e) => {
  let [r, n] = (0, lb.useState)(0),
    i = (0, lb.useRef)(null),
    a = (0, lb.useRef)(e),
    s = (0, lb.useRef)(t);
  return (
    (0, lb.useEffect)(() => {
      let o = !1;
      return (
        a.current !== e && ((o = !0), (a.current = e)),
        s.current === !1 && t && (o = !0),
        o && n(0),
        (s.current = t),
        t
          ? (i.current && clearInterval(i.current),
            (i.current = setInterval(() => {
              n((l) => l + 1);
            }, 1e3)))
          : i.current && (clearInterval(i.current), (i.current = null)),
        () => {
          i.current && (clearInterval(i.current), (i.current = null));
        }
      );
    }, [t, e]),
    r
  );
};
var ub = qe(or(), 1);
var EDn = 5e3;
function yDn() {
  return [
    'Generating responses with 110% accuracy',
    'Reticulating splines...',
    'Consulting the Oracle...',
    'Waking up the AI overlords...',
    'Booting up consciousness...',
    'Calibrating neural pathways...',
    'Compiling ideas into thoughts...',
    'Loading witty loading messages...',
    'Calculating the meaning of life...',
    'Sharpening the algorithms...',
    'Preparing digital magic tricks...',
    'Downloading more RAM...',
    'Compressing algorithms...',
    'Decompressing responses...',
    'Rearranging the bits...',
    'Initializing the response factory...',
    'Assembling the knowledge engine...',
    'Polishing the AI gemstones...',
    'Warming up the neural networks...',
    'Fine-tuning the intelligence...',
    'Loading AI with coffee...',
    'Preparing your AI-powered response...',
    'Consulting the digital encyclopedia...',
    'Generating thoughts with 99.9% confidence',
  ];
}
function oXt(t, e) {
  let r = (0, ub.useMemo)(() => yDn(), []),
    [n, i] = (0, ub.useState)(() => r[0] ?? 'Loading...'),
    a = (0, ub.useCallback)(() => {
      if (r.length === 0) return 'Loading...';
      let s = Math.floor(Math.random() * r.length);
      return r[s];
    }, [r]);
  return (
    (0, ub.useEffect)(() => {
      let s = null;
      if (e) i('Waiting for user confirmation...');
      else if (t) {
        let o = a();
        (i(o),
          (s = setInterval(() => {
            i((l) => {
              let u = r.indexOf(l);
              if (u === -1) return r[0];
              let c = (u + 1) % r.length;
              return r[c];
            });
          }, EDn)));
      } else i(r[0]);
      return () => {
        s && clearInterval(s);
      };
    }, [t, e, a, r]),
    n
  );
}
var cB = qe(or(), 1);
var lXt = (t, e) => {
  let [r, n] = (0, cB.useState)(0),
    i = t === 'responding',
    a = sXt(i, r),
    s = t === 'responding',
    o = t === 'waiting_for_confirmation',
    l = oXt(s, o),
    u = e && t !== 'idle' ? e : l,
    [c, p] = (0, cB.useState)(0),
    h = (0, cB.useRef)(null);
  return (
    (0, cB.useEffect)(() => {
      (h.current === 'waiting_for_confirmation' && t === 'responding'
        ? (n((m) => m + 1), p(0))
        : t === 'idle' && h.current === 'responding'
          ? (n((m) => m + 1), p(0))
          : t === 'waiting_for_confirmation' && p(a),
        (h.current = t));
    }, [t, a]),
    { elapsedTime: t === 'waiting_for_confirmation' ? c : a, currentLoadingPhrase: u }
  );
};
var Qv = qe(or(), 1);
var uXt = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    blanchedalmond: '#ffebcd',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgrey: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgrey: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    whitesmoke: '#f5f5f5',
    yellowgreen: '#9acd32',
  },
  vDn = new Set([
    'black',
    'red',
    'green',
    'yellow',
    'blue',
    'cyan',
    'magenta',
    'white',
    'gray',
    'grey',
    'blackbright',
    'redbright',
    'greenbright',
    'yellowbright',
    'bluebright',
    'cyanbright',
    'magentabright',
    'whitebright',
  ]);
function cXt(t) {
  let e = t.toLowerCase();
  if (e.startsWith('#')) return /^#[0-9A-Fa-f]{3}([0-9A-Fa-f]{3})?$/.test(t) ? e : void 0;
  if (vDn.has(e)) return e;
  if (uXt[e]) return uXt[e];
  console.warn(`[ColorUtils] Could not resolve color "${t}" to an Ink-compatible format.`);
}
var ci = {
    type: 'light',
    Background: '#FAFAFA',
    Foreground: '#3C3C43',
    LightBlue: '#89BDCD',
    AccentBlue: '#3B82F6',
    AccentPurple: '#8B5CF6',
    AccentCyan: '#06B6D4',
    AccentGreen: '#3CA84B',
    AccentYellow: '#D5A40A',
    AccentRed: '#DD4C4C',
    DiffAdded: '#C6EAD8',
    DiffRemoved: '#FFCCCC',
    Comment: '#008000',
    Gray: '#97a0b0',
    GradientColors: ['#4796E4', '#847ACE', '#C3677F'],
  },
  On = {
    type: 'dark',
    Background: '#1E1E2E',
    Foreground: '#CDD6F4',
    LightBlue: '#ADD8E6',
    AccentBlue: '#89B4FA',
    AccentPurple: '#CBA6F7',
    AccentCyan: '#89DCEB',
    AccentGreen: '#A6E3A1',
    AccentYellow: '#F9E2AF',
    AccentRed: '#F38BA8',
    DiffAdded: '#28350B',
    DiffRemoved: '#430000',
    Comment: '#6C7086',
    Gray: '#6C7086',
    GradientColors: ['#8b20c5ff', '#e4b424ff', '#C3677F'],
  },
  Gf = {
    type: 'ansi',
    Background: 'black',
    Foreground: 'white',
    LightBlue: 'blue',
    AccentBlue: 'blue',
    AccentPurple: 'magenta',
    AccentCyan: 'cyan',
    AccentGreen: 'green',
    AccentYellow: 'yellow',
    AccentRed: 'red',
    DiffAdded: 'green',
    DiffRemoved: 'red',
    Comment: 'gray',
    Gray: 'gray',
  },
  Xs = class t {
    constructor(e, r, n, i, a) {
      this.name = e;
      this.type = r;
      this.colors = i;
      this.semanticColors = a;
      this._colorMap = Object.freeze(this._buildColorMap(n));
      let s = n.hljs?.color;
      this.defaultColor = (s ? t._resolveColor(s) : void 0) ?? '';
    }
    defaultColor;
    _colorMap;
    getInkColor(e) {
      return this._colorMap[e];
    }
    static _resolveColor(e) {
      return cXt(e);
    }
    _buildColorMap(e) {
      let r = {};
      for (let n in e) {
        if (!n.startsWith('hljs-') && n !== 'hljs') continue;
        let i = e[n];
        if (i?.color) {
          let a = t._resolveColor(i.color);
          a !== void 0 && (r[n] = a);
        }
      }
      return r;
    }
  };
