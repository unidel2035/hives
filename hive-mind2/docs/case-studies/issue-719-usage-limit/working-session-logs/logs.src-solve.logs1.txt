      issueNumber,
      prNumber,
      prUrl,
      branchName,
      tempDir,
      isContinueMode,
      mergeStateStatus,
      forkedRepo,
      feedbackLines,
      forkActionsUrl,
      owner,
      repo,
      argv,
      log,
      setLogFile,
      getLogFile,
      formatAligned,
      getResourceSnapshot,
      opencodePath,
      $
    });
  } else if (argv.tool === 'codex') {
    const codexLib = await import('./codex.lib.mjs');
    const { executeCodex } = codexLib;
    const codexPath = process.env.CODEX_PATH || 'codex';

    toolResult = await executeCodex({
      issueUrl,
      issueNumber,
      prNumber,
      prUrl,
      branchName,
      tempDir,
      isContinueMode,
      mergeStateStatus,
      forkedRepo,
      feedbackLines,
      forkActionsUrl,
      owner,
      repo,
      argv,
      log,
      setLogFile,
      getLogFile,
      formatAligned,
      getResourceSnapshot,
      codexPath,
      $
    });
  } else {
    // Default to Claude
    const claudeResult = await executeClaude({
      issueUrl,
      issueNumber,
      prNumber,
      prUrl,
      branchName,
      tempDir,
      isContinueMode,
      mergeStateStatus,
      forkedRepo,
      feedbackLines,
      forkActionsUrl,
      owner,
      repo,
      argv,
      log,
      setLogFile,
      getLogFile,
      formatAligned,
      getResourceSnapshot,
      claudePath,
      $
    });
    toolResult = claudeResult;
  }

  const { success } = toolResult;
  let sessionId = toolResult.sessionId;
  let anthropicTotalCostUSD = toolResult.anthropicTotalCostUSD;
  limitReached = toolResult.limitReached;
  cleanupContext.limitReached = limitReached;

  if (!success) {
    // If --attach-logs is enabled and we have a PR, attach failure logs before exiting
    if (shouldAttachLogs && sessionId && global.createdPR && global.createdPR.number) {
      await log('\nüìÑ Attaching failure logs to Pull Request...');
      try {
        // Build resume command if we have session info
        const resumeCommand = sessionId ? `${process.argv[0]} ${process.argv[1]} ${issueUrl} --resume ${sessionId}` : null;
        const logUploadSuccess = await attachLogToGitHub({
          logFile: getLogFile(),
          targetType: 'pr',
          targetNumber: global.createdPR.number,
          owner,
          repo,
          $,
          log,
          sanitizeLogContent,
          // For usage limit, use a dedicated comment format to make it clear and actionable
          isUsageLimit: !!limitReached,
          limitResetTime: limitReached ? toolResult.limitResetTime : null,
          toolName: (argv.tool || 'AI tool').toString().toLowerCase() === 'claude' ? 'Claude' :
                    (argv.tool || 'AI tool').toString().toLowerCase() === 'codex' ? 'Codex' :
                    (argv.tool || 'AI tool').toString().toLowerCase() === 'opencode' ? 'OpenCode' : 'AI tool',
          resumeCommand,
          // If not a usage limit case, fall back to generic failure format
          errorMessage: limitReached ? undefined : `${argv.tool.toUpperCase()} execution failed`
        });

        if (logUploadSuccess) {
          await log('  ‚úÖ Failure logs uploaded successfully');
        } else {
          await log('  ‚ö†Ô∏è  Failed to upload logs', { verbose: true });
        }
      } catch (uploadError) {
        await log(`  ‚ö†Ô∏è  Error uploading logs: ${uploadError.message}`, { verbose: true });
      }
    }

    await safeExit(1, `${argv.tool.toUpperCase()} execution failed`);
  }

  // Check for uncommitted changes
  // When limit is reached, force auto-commit of any uncommitted changes to preserve work
  const shouldAutoCommit = argv['auto-commit-uncommitted-changes'] || limitReached;
  const autoRestartEnabled = argv['autoRestartOnUncommittedChanges'] !== false;
  const shouldRestart = await checkForUncommittedChanges(tempDir, owner, repo, branchName, $, log, shouldAutoCommit, autoRestartEnabled);

  // Remove CLAUDE.md now that Claude command has finished
  await cleanupClaudeFile(tempDir, branchName, claudeCommitHash);

  // Show summary of session and log file
  await showSessionSummary(sessionId, limitReached, argv, issueUrl, tempDir, shouldAttachLogs);

  // Search for newly created pull requests and comments
  // Pass shouldRestart to prevent early exit when auto-restart is needed
  await verifyResults(owner, repo, branchName, issueNumber, prNumber, prUrl, referenceTime, argv, shouldAttachLogs, shouldRestart, sessionId, tempDir, anthropicTotalCostUSD);

  // Start watch mode if enabled OR if we need to handle uncommitted changes
  if (argv.verbose) {
    await log('');
    await log('üîç Auto-restart debug:', { verbose: true });
    await log(`   argv.watch (user flag): ${argv.watch}`, { verbose: true });
    await log(`   shouldRestart (auto-detected): ${shouldRestart}`, { verbose: true });
    await log(`   temporaryWatch (will be enabled): ${shouldRestart && !argv.watch}`, { verbose: true });
    await log(`   prNumber: ${prNumber || 'null'}`, { verbose: true });
    await log(`   prBranch: ${prBranch || 'null'}`, { verbose: true });
    await log(`   branchName: ${branchName}`, { verbose: true });
    await log(`   isContinueMode: ${isContinueMode}`, { verbose: true });
  }

  // If uncommitted changes detected and auto-commit is disabled, enter temporary watch mode
  const temporaryWatchMode = shouldRestart && !argv.watch;
  if (temporaryWatchMode) {
    await log('');
    await log('üîÑ AUTO-RESTART: Uncommitted changes detected');
    await log('   Starting temporary monitoring cycle (NOT --watch mode)');
    await log('   The tool will run once more to commit the changes');
    await log('   Will exit automatically after changes are committed');
    await log('');
  }

  const watchResult = await startWatchMode({
    issueUrl,
    owner,
    repo,
    issueNumber,
    prNumber,
    prBranch,
    branchName,
    tempDir,
    argv: {
      ...argv,
      watch: argv.watch || shouldRestart, // Enable watch if uncommitted changes
      temporaryWatch: temporaryWatchMode  // Flag to indicate temporary watch mode
    }
  });

  // Update session data with latest from watch mode for accurate pricing
  if (watchResult && watchResult.latestSessionId) {
