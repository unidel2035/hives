      
      await log('   ðŸ”„ Claude will now run with Node.js runtime');
      
    } catch (error) {
      await log(`âŒ Failed to restore Claude to Node.js: ${cleanErrorMessage(error)}`, { level: 'error' });
      process.exit(1);
    }
    
    // Exit after restoring runtime
    process.exit(0);
  }
};
/**
 * Execute Claude with all prompts and settings
 * This is the main entry point that handles all prompt building and execution
 * @param {Object} params - Parameters for Claude execution
 * @returns {Object} Result of the execution including success status and session info
 */
export const executeClaude = async (params) => {
  const {
    issueUrl,
    issueNumber,
    prNumber,
    prUrl,
    branchName,
    tempDir,
    isContinueMode,
    mergeStateStatus,
    forkedRepo,
    feedbackLines,
    forkActionsUrl,
    owner,
    repo,
    argv,
    log,
    setLogFile,
    getLogFile,
    formatAligned,
    getResourceSnapshot,
    claudePath,
    $
  } = params;
  // Import prompt building functions from claude.prompts.lib.mjs
  const { buildUserPrompt, buildSystemPrompt } = await import('./claude.prompts.lib.mjs');
  // Build the user prompt
  const prompt = buildUserPrompt({
    issueUrl,
    issueNumber,
    prNumber,
    prUrl,
    branchName,
    tempDir,
    isContinueMode,
    mergeStateStatus,
    forkedRepo,
    feedbackLines,
    forkActionsUrl,
    owner,
    repo,
    argv
  });
  // Build the system prompt
  const systemPrompt = buildSystemPrompt({
    owner,
    repo,
    issueNumber,
    issueUrl,
    prNumber,
    prUrl,
    branchName,
    tempDir,
    isContinueMode,
    forkedRepo,
    argv
  });
  // Log prompt details in verbose mode
  if (argv.verbose) {
    await log('\nðŸ“ Final prompt structure:', { verbose: true });
    await log(`   Characters: ${prompt.length}`, { verbose: true });
    await log(`   System prompt characters: ${systemPrompt.length}`, { verbose: true });
    if (feedbackLines && feedbackLines.length > 0) {
      await log('   Feedback info: Included', { verbose: true });
    }
    // In dry-run mode, output the actual prompts for debugging
    if (argv.dryRun) {
      await log('\nðŸ“‹ User prompt content:', { verbose: true });
      await log('---BEGIN USER PROMPT---', { verbose: true });
      await log(prompt, { verbose: true });
      await log('---END USER PROMPT---', { verbose: true });
      await log('\nðŸ“‹ System prompt content:', { verbose: true });
      await log('---BEGIN SYSTEM PROMPT---', { verbose: true });
      await log(systemPrompt, { verbose: true });
      await log('---END SYSTEM PROMPT---', { verbose: true });
    }
  }
  // Escape prompts for shell usage
  const escapedPrompt = prompt.replace(/"/g, '\\"').replace(/\$/g, '\\$');
  const escapedSystemPrompt = systemPrompt.replace(/"/g, '\\"').replace(/\$/g, '\\$');
  // Execute the Claude command
  return await executeClaudeCommand({
    tempDir,
    branchName,
    prompt,
    systemPrompt,
    escapedPrompt,
    escapedSystemPrompt,
    argv,
    log,
    setLogFile,
    getLogFile,
    formatAligned,
    getResourceSnapshot,
    forkedRepo,
    feedbackLines,
    claudePath,
    $
  });
};
/**
 * Calculate total token usage from a session's JSONL file
 * @param {string} sessionId - The session ID
 * @param {string} tempDir - The temporary directory where the session ran
 * @returns {Object} Token usage statistics
 */
/**
 * Fetches model information from pricing API
 * @param {string} modelId - The model ID (e.g., "claude-sonnet-4-5-20250929")
 * @returns {Promise<Object|null>} Model information or null if not found
 */
export const fetchModelInfo = async (modelId) => {
  try {
    const https = (await use('https')).default;
    return new Promise((resolve, reject) => {
      https.get('https://models.dev/api.json', (res) => {
        let data = '';
        res.on('data', (chunk) => {
          data += chunk;
        });
        res.on('end', () => {
          try {
            const apiData = JSON.parse(data);
            // Search for the model across all providers
            for (const provider of Object.values(apiData)) {
              if (provider.models && provider.models[modelId]) {
                const modelInfo = provider.models[modelId];
                // Add provider info
                modelInfo.provider = provider.name || provider.id;
                resolve(modelInfo);
                return;
              }
            }
            // Model not found
            resolve(null);
          } catch (parseError) {
            reject(parseError);
          }
        });
      }).on('error', (err) => {
        reject(err);
      });
    });
  } catch {
    // If we can't fetch model info, return null and continue without it
    return null;
  }
};
/**
 * Calculate USD cost for a model's usage with detailed breakdown
 * @param {Object} usage - Token usage object
 * @param {Object} modelInfo - Model information from pricing API
 * @param {boolean} includeBreakdown - Whether to include detailed calculation breakdown
