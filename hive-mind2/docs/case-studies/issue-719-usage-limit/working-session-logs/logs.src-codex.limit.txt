19:import { detectUsageLimit, formatUsageLimitMessage } from './usage-limit.lib.mjs';
279:    // Codex doesn't have separate system prompt support in CLI mode
320:      let limitReached = false;
321:      let limitResetTime = null;
396:        // Check for usage limit errors first (more specific)
397:        const limitInfo = detectUsageLimit(lastMessage);
398:        if (limitInfo.isUsageLimit) {
399:          limitReached = true;
400:          limitResetTime = limitInfo.resetTime;
405:            resetTime: limitInfo.resetTime,
425:          limitReached,
426:          limitResetTime
435:        limitReached,
436:        limitResetTime
459:        limitReached: false,
460:        limitResetTime: null
        })`cat ${promptFile} | ${codexPath} exec resume ${argv.resume} --json --skip-git-repo-check --dangerously-bypass-approvals-and-sandbox`;
      } else {
        execCommand = $({
          cwd: tempDir,
          mirror: false
        })`cat ${promptFile} | ${codexPath} exec --model ${mappedModel} --json --skip-git-repo-check --dangerously-bypass-approvals-and-sandbox`;
      }

      await log(`${formatAligned('üìã', 'Command details:', '')}`);
      await log(formatAligned('üìÇ', 'Working directory:', tempDir, 2));
      await log(formatAligned('üåø', 'Branch:', branchName, 2));
      await log(formatAligned('ü§ñ', 'Model:', `Codex ${argv.model.toUpperCase()}`, 2));
      if (argv.fork && forkedRepo) {
        await log(formatAligned('üç¥', 'Fork:', forkedRepo, 2));
      }

      await log(`\n${formatAligned('‚ñ∂Ô∏è', 'Streaming output:', '')}\n`);

      let exitCode = 0;
      let sessionId = null;
      let limitReached = false;
      let limitResetTime = null;
      let lastMessage = '';
      let authError = false;

      for await (const chunk of execCommand.stream()) {
        if (chunk.type === 'stdout') {
          const output = chunk.data.toString();
          await log(output);
          lastMessage = output;

          // Try to parse JSON output to extract session info
          // Codex CLI uses thread_id instead of session_id
          try {
            const lines = output.split('\n');
            for (const line of lines) {
              if (!line.trim()) continue;
              const data = JSON.parse(line);
              // Check for both thread_id (codex) and session_id (legacy)
              if ((data.thread_id || data.session_id) && !sessionId) {
                sessionId = data.thread_id || data.session_id;
                await log(`üìå Session ID: ${sessionId}`);
              }

              // Check for authentication errors (401 Unauthorized)
              // These should never be retried as they indicate missing/invalid credentials
              if (data.type === 'error' && data.message &&
                  (data.message.includes('401 Unauthorized') ||
                   data.message.includes('401') ||
                   data.message.includes('Unauthorized'))) {
                authError = true;
                await log('\n‚ùå Authentication error detected: 401 Unauthorized', { level: 'error' });
                await log('   This error cannot be resolved by retrying.', { level: 'error' });
                await log('   üí° Please run: codex login', { level: 'error' });
              }

              // Also check turn.failed events for auth errors
              if (data.type === 'turn.failed' && data.error && data.error.message &&
                  (data.error.message.includes('401 Unauthorized') ||
                   data.error.message.includes('401') ||
                   data.error.message.includes('Unauthorized'))) {
                authError = true;
                await log('\n‚ùå Authentication error detected in turn.failed event', { level: 'error' });
                await log('   This error cannot be resolved by retrying.', { level: 'error' });
                await log('   üí° Please run: codex login', { level: 'error' });
              }
            }
          } catch {
            // Not JSON, continue
          }
        }

        if (chunk.type === 'stderr') {
          const errorOutput = chunk.data.toString();
          if (errorOutput) {
            await log(errorOutput, { stream: 'stderr' });
          }
        } else if (chunk.type === 'exit') {
          exitCode = chunk.code;
        }
      }

      // Check for authentication errors first - these should never be retried
      if (authError) {
        const resourcesAfter = await getResourceSnapshot();
        await log('\nüìà System resources after execution:', { verbose: true });
        await log(`   Memory: ${resourcesAfter.memory.split('\n')[1]}`, { verbose: true });
        await log(`   Load: ${resourcesAfter.load}`, { verbose: true });

        // Throw an error to stop retries and propagate the auth failure
        const error = new Error('Codex authentication failed - 401 Unauthorized. Please run: codex login');
        error.isAuthError = true;
        throw error;
      }

      if (exitCode !== 0) {
        // Check for usage limit errors first (more specific)
        const limitInfo = detectUsageLimit(lastMessage);
        if (limitInfo.isUsageLimit) {
          limitReached = true;
          limitResetTime = limitInfo.resetTime;

          // Format and display user-friendly message
          const messageLines = formatUsageLimitMessage({
            tool: 'Codex',
            resetTime: limitInfo.resetTime,
            sessionId,
            resumeCommand: sessionId ? `${process.argv[0]} ${process.argv[1]} ${argv.url} --resume ${sessionId}` : null
          });

          for (const line of messageLines) {
            await log(line, { level: 'warning' });
          }
        } else {
          await log(`\n\n‚ùå Codex command failed with exit code ${exitCode}`, { level: 'error' });
        }

        const resourcesAfter = await getResourceSnapshot();
        await log('\nüìà System resources after execution:', { verbose: true });
        await log(`   Memory: ${resourcesAfter.memory.split('\n')[1]}`, { verbose: true });
        await log(`   Load: ${resourcesAfter.load}`, { verbose: true });

        return {
          success: false,
          sessionId,
          limitReached,
          limitResetTime
        };
      }

      await log('\n\n‚úÖ Codex command completed');
