#!/usr/bin/env node

// Auto-continue module for solve command
// Extracted from solve.mjs to keep files under 1500 lines

// Use use-m to dynamically import modules for cross-runtime compatibility
// Check if use is already defined globally (when imported from solve.mjs)
// If not, fetch it (when running standalone)
if (typeof globalThis.use === 'undefined') {
  globalThis.use = (await eval(await (await fetch('https://unpkg.com/use-m/use.js')).text())).use;
}
const use = globalThis.use;

// Use command-stream for consistent $ behavior across runtimes
const { $ } = await use('command-stream');

// Import shared library functions
const lib = await import('./lib.mjs');
const {
  log,
  cleanErrorMessage
} = lib;

// Import exit handler
import { safeExit } from './exit-handler.lib.mjs';

// Import branch name validation functions
const branchLib = await import('./solve.branch.lib.mjs');
const {
  getIssueBranchPrefix,
  matchesIssuePattern
} = branchLib;

// Import GitHub-related functions
const githubLib = await import('./github.lib.mjs');
const {
  checkFileInBranch
} = githubLib;

// Import validation functions for time parsing
const validation = await import('./solve.validation.lib.mjs');

// Import Sentry integration
const sentryLib = await import('./sentry.lib.mjs');
const { reportError } = sentryLib;

// Import GitHub linking detection library
const githubLinking = await import('./github-linking.lib.mjs');
const { extractLinkedIssueNumber } = githubLinking;

// Import configuration
import { autoContinue } from './config.lib.mjs';

const {
  calculateWaitTime
} = validation;

// Auto-continue function that waits until limit resets
export const autoContinueWhenLimitResets = async (issueUrl, sessionId, argv, shouldAttachLogs) => {
  try {
    const resetTime = global.limitResetTime;
    const waitMs = calculateWaitTime(resetTime);

    await log(`\nâ° Waiting until ${resetTime} for limit to reset...`);
    await log(`   Wait time: ${Math.round(waitMs / (1000 * 60))} minutes`);
    await log(`   Current time: ${new Date().toLocaleTimeString()}`);

    // Show countdown every 30 minutes for long waits, every minute for short waits
    const countdownInterval = waitMs > 30 * 60 * 1000 ? 30 * 60 * 1000 : 60 * 1000;
    let remainingMs = waitMs;

    const countdownTimer = setInterval(async () => {
      remainingMs -= countdownInterval;
      if (remainingMs > 0) {
        const remainingMinutes = Math.round(remainingMs / (1000 * 60));
        await log(`â³ ${remainingMinutes} minutes remaining until ${resetTime}`);
      }
    }, countdownInterval);

    // Wait until reset time
    await new Promise(resolve => setTimeout(resolve, waitMs));
    clearInterval(countdownTimer);

    await log('\nâœ… Limit reset time reached! Resuming session...');
    await log(`   Current time: ${new Date().toLocaleTimeString()}`);

    // Recursively call the solve script with --resume
    // We need to reconstruct the command with appropriate flags
    const childProcess = await import('child_process');

    // Build the resume command
    const resumeArgs = [
      process.argv[1], // solve.mjs path
      issueUrl,
      '--resume', sessionId,
      '--auto-continue-limit' // Keep auto-continue-limit enabled
    ];

    // Preserve other flags from original invocation
    if (argv.model !== 'sonnet') resumeArgs.push('--model', argv.model);
    if (argv.verbose) resumeArgs.push('--verbose');
    if (argv.fork) resumeArgs.push('--fork');
    if (shouldAttachLogs) resumeArgs.push('--attach-logs');

    await log(`\nðŸ”„ Executing: ${resumeArgs.join(' ')}`);

    // Execute the resume command
    const child = childProcess.spawn('node', resumeArgs, {
      stdio: 'inherit',
      cwd: process.cwd()
    });

    child.on('close', (code) => {
      process.exit(code);
    });

  } catch (error) {
    reportError(error, {
      context: 'auto_continue_with_command',
      issueUrl,
      issueUrl,
      sessionId,
      operation: 'auto_continue_execution'
    });
    await log(`\nâŒ Auto-continue failed: ${cleanErrorMessage(error)}`, { level: 'error' });
    await log('\nðŸ”„ Manual resume command:');
    await log(`./solve.mjs "${issueUrl}" --resume ${sessionId}`);
    await safeExit(1, 'Auto-continue failed');
  }
};

// Auto-continue logic: check for existing PRs if --auto-continue is enabled
export const checkExistingPRsForAutoContinue = async (argv, isIssueUrl, owner, repo, urlNumber) => {
  let isContinueMode = false;
  let prNumber = null;
  let prBranch = null;
  let issueNumber = null;

  if (argv.autoContinue && isIssueUrl) {
    issueNumber = urlNumber;
    await log(`ðŸ” Auto-continue enabled: Checking for existing PRs for issue #${issueNumber}...`);

    try {
      // Get all PRs linked to this issue
      const prListResult = await $`gh pr list --repo ${owner}/${repo} --search "linked:issue-${issueNumber}" --json number,createdAt,headRefName,isDraft,state --limit 10`;

      if (prListResult.code === 0) {
        const prs = JSON.parse(prListResult.stdout.toString().trim() || '[]');

        if (prs.length > 0) {
          await log(`ðŸ“‹ Found ${prs.length} existing PR(s) linked to issue #${issueNumber}`);

          // Find PRs that are older than 24 hours
          const now = new Date();
          const twentyFourHoursAgo = new Date(now.getTime() - autoContinue.ageThresholdHours * 60 * 60 * 1000);

          for (const pr of prs) {
            const createdAt = new Date(pr.createdAt);
            const ageHours = Math.floor((now - createdAt) / (1000 * 60 * 60));

            await log(`  PR #${pr.number}: created ${ageHours}h ago (${pr.state}, ${pr.isDraft ? 'draft' : 'ready'})`);

            // Check if PR is open (not closed)
            if (pr.state === 'OPEN') {
              // CRITICAL: Validate that branch name matches the expected pattern for this issue
              // Branch naming convention: issue-{issueNumber}-{randomHash} (supports both 8-char legacy and 12-char new formats)
              if (!matchesIssuePattern(pr.headRefName, issueNumber)) {
                const expectedBranchPrefix = getIssueBranchPrefix(issueNumber);
                await log(`  PR #${pr.number}: Branch '${pr.headRefName}' doesn't match expected pattern '${expectedBranchPrefix}*' - skipping`);
                continue;
              }

              // Check if CLAUDE.md exists in this PR branch
              const claudeMdExists = await checkFileInBranch(owner, repo, 'CLAUDE.md', pr.headRefName);

              if (!claudeMdExists) {
                await log(`âœ… Auto-continue: Using PR #${pr.number} (CLAUDE.md missing - work completed, branch: ${pr.headRefName})`);

                // Switch to continue mode immediately (don't wait 24 hours if CLAUDE.md is missing)
                isContinueMode = true;
                prNumber = pr.number;
                prBranch = pr.headRefName;
                if (argv.verbose) {
                  await log('   Continue mode activated: Auto-continue (CLAUDE.md missing)', { verbose: true });
                  await log(`   PR Number: ${prNumber}`, { verbose: true });
                  await log(`   PR Branch: ${prBranch}`, { verbose: true });
                }
                break;
              } else if (createdAt < twentyFourHoursAgo) {
                await log(`âœ… Auto-continue: Using PR #${pr.number} (created ${ageHours}h ago, branch: ${pr.headRefName})`);

                // Switch to continue mode
                isContinueMode = true;
                prNumber = pr.number;
                prBranch = pr.headRefName;
                if (argv.verbose) {
                  await log('   Continue mode activated: Auto-continue (24h+ old PR)', { verbose: true });
                  await log(`   PR Number: ${prNumber}`, { verbose: true });
                  await log(`   PR Branch: ${prBranch}`, { verbose: true });
                  await log(`   PR Age: ${ageHours} hours`, { verbose: true });
                }
