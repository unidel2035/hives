   388	
   389	        // Throw an error to stop retries and propagate the auth failure
   390	        const error = new Error('Codex authentication failed - 401 Unauthorized. Please run: codex login');
   391	        error.isAuthError = true;
   392	        throw error;
   393	      }
   394	
   395	      if (exitCode !== 0) {
   396	        // Check for usage limit errors first (more specific)
   397	        const limitInfo = detectUsageLimit(lastMessage);
   398	        if (limitInfo.isUsageLimit) {
   399	          limitReached = true;
   400	          limitResetTime = limitInfo.resetTime;
   401	
   402	          // Format and display user-friendly message
   403	          const messageLines = formatUsageLimitMessage({
   404	            tool: 'Codex',
   405	            resetTime: limitInfo.resetTime,
   406	            sessionId,
   407	            resumeCommand: sessionId ? `${process.argv[0]} ${process.argv[1]} ${argv.url} --resume ${sessionId}` : null
   408	          });
   409	
   410	          for (const line of messageLines) {
   411	            await log(line, { level: 'warning' });
   412	          }
   413	        } else {
   414	          await log(`\n\nâŒ Codex command failed with exit code ${exitCode}`, { level: 'error' });
   415	        }
   416	
   417	        const resourcesAfter = await getResourceSnapshot();
   418	        await log('\nðŸ“ˆ System resources after execution:', { verbose: true });
   419	        await log(`   Memory: ${resourcesAfter.memory.split('\n')[1]}`, { verbose: true });
   420	        await log(`   Load: ${resourcesAfter.load}`, { verbose: true });
   421	
   422	        return {
   423	          success: false,
   424	          sessionId,
   425	          limitReached,
   426	          limitResetTime
   427	        };
   428	      }
   429	
   430	      await log('\n\nâœ… Codex command completed');
   431	
   432	      return {
   433	        success: true,
   434	        sessionId,
   435	        limitReached,
   436	        limitResetTime
   437	      };
   438	    } catch (error) {
   439	      // Don't report auth errors to Sentry as they are user configuration issues
   440	      if (!error.isAuthError) {
   441	        reportError(error, {
   442	          context: 'execute_codex',
   443	          command: params.command,
   444	          codexPath: params.codexPath,
   445	          operation: 'run_codex_command'
   446	        });
   447	      }
   448	
   449	      await log(`\n\nâŒ Error executing Codex command: ${error.message}`, { level: 'error' });
   450	
   451	      // Re-throw auth errors to stop any outer retry loops
   452	      if (error.isAuthError) {
   453	        throw error;
   454	      }
   455	
   456	      return {
   457	        success: false,
   458	        sessionId: null,
   459	        limitReached: false,
   460	        limitResetTime: null
   461	      };
   462	    }
   463	  };
   464	
   465	  // Start the execution with retry logic
   466	  return await executeWithRetry();
   467	};
   468	
   469	export const checkForUncommittedChanges = async (tempDir, owner, repo, branchName, $, log, autoCommit = false, autoRestartEnabled = true) => {
   470	  // Similar to Claude and OpenCode version, check for uncommitted changes
