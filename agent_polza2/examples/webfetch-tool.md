# Example of Web Fetch tool usage

```bash
konard@MacBook-Pro-Konstantin ~ % echo "Quote me content from habr.com/en/articles/895896" | agent
{
  "type": "step_start",
  "timestamp": 1763624898908,
  "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
  "part": {
    "id": "prt_aa03c515b0019XWdhPtSyMCvVo",
    "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
    "messageID": "msg_aa03c47ca001RyPgbaOc92qMzv",
    "type": "step-start"
  }
}
{
  "type": "tool_use",
  "timestamp": 1763624905144,
  "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
  "part": {
    "id": "prt_aa03c63e0001oO9LMMuKG5AJ0v",
    "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
    "messageID": "msg_aa03c47ca001RyPgbaOc92qMzv",
    "type": "tool",
    "callID": "call_42123294",
    "tool": "webfetch",
    "state": {
      "status": "completed",
      "input": {
        "url": "https://habr.com/en/articles/895896",
        "format": "markdown"
      },
      "output": "The Links Theory 0.0.2 / Habr                                                                                   \n\n[Habr](/en/feed)[All streams](/en/articles/)\n\n[Search](/en/search/)\n\n[Write a publication](/en/sandbox/start/)\n\nSettings\n\n[Login](https://habr.com/kek/v1/auth/habrahabr/?back=/en/articles/895896/&hl=en)\n\nPull to refresh\n\n[\n\n![](//habrastorage.org/r/w48/getpro/habr/avatars/faa/6f7/0a5/faa6f70a548befa99b28025c5dfcdd6d.jpg)\n\n](/en/users/Konard/ \"Konard\")[Konard](/en/users/Konard/) Apr 1 at 12:15\n\n# The Links Theory 0.0.2\n\nLevel of difficultyMedium\n\nReading time27 min\n\nViews2.4K\n\n[Data Engineering \\*](/en/hubs/data_engineering/) [Open source \\*](/en/hubs/open_source/) [Mathematics \\*](/en/hubs/maths/) [Abnormal programming \\*](/en/hubs/crazydev/) [Programming \\*](/en/hubs/programming/)\n\nTranslation\n\n[Original author: Vasily Solopov, Roman Vertushkin, Ivan Glazunov, Konstantin Diachenko](https://habr.com/ru/companies/deepfoundation/articles/804617/)\n\nLast April 1st, as you might have guessed, we were joking. It’s time to fix that, and now everything is ![100\\%](https://habrastorage.org/getpro/habr/upload_files/298/8ef/3a6/2988ef3a67988537121da1f6acea3521.svg) serious.\n\n#### TL;DR (too long; didn't read)\n\nThis article contains many letters, but it can be represented using just 4 symbols from [set theory](https://en.wikipedia.org/wiki/Set_theory):\n\n> ![L \\to L^2](https://habrastorage.org/getpro/habr/upload_files/42d/52f/71e/42d52f71e0454feb23d2d4d6773ab933.svg)\n\nEverything else follows from them.\n\n## Overview\n\nThis article is primarily aimed at programmers and mathematicians, yet we’ve designed it to be accessible to anyone interested in the ideas it presents. We believe that the concepts discussed here can serve as inspiration across a wide range of scientific disciplines.\n\nOur goal was to create a self-contained text that guides you through each topic in a clear, logical order. Throughout the article, you’ll find links to [Wikipedia](https://www.wikipedia.org) for those who wish to explore specific terms or concepts in more depth — but this is entirely optional. The text is intended to be easily understood when read from start to finish.\n\nEvery symbol and formula is explained individually, with concise definitions provided where needed. We’ve also included images to help illustrate key ideas. If you come across anything that isn’t clear, please let us know so we can improve it.\n\n## Comparison of theories\n\nTo quickly dive in, we begin by comparing the mathematical foundations of the two most popular [data models](https://en.wikipedia.org/wiki/Data_model) with that of the [associative model of data](https://web.archive.org/web/20210814063207/https://en.wikipedia.org/wiki/Associative_model_of_data).\n\nIn the course of our research, we discovered that traditional theories were sometimes overly complex or redundant, while at other times they imposed too many artificial constraints.\n\nThis overall lack of flexibility, adaptability, and universality motivated us to search for a simpler yet all-encompassing informational theory and a data storage model that future artificial intelligence could easily understand and effectively utilize. Along the way, we drew inspiration from the workings of our own associative memory and associative thought processes.\n\n### Relational Algebra\n\n[Relational algebra](https://en.wikipedia.org/wiki/Relational_algebra) and the [relational model](https://en.wikipedia.org/wiki/Relational_model) are based on the concepts of [relations](https://en.wikipedia.org/wiki/Relation_\\(database\\)) and [n-tuples](https://en.wikipedia.org/wiki/Tuple).\n\nA [relation](https://en.wikipedia.org/wiki/Relation_\\(database\\)) is defined as a [set](https://en.wikipedia.org/wiki/Set_\\(mathematics\\)) of [n-tuples](https://en.wikipedia.org/wiki/Tuple):\n\n> ![\\mathbf{R \\subseteq S_1 \\times S_2 \\times \\dots \\times S_n.}](https://habrastorage.org/getpro/habr/upload_files/e61/ff7/187/e61ff7187b7395121c7d84e471201746.svg) [\\[1\\]](https://dl.acm.org/doi/abs/10.1145/362384.362685)\n\n![Рис. 1. Таблица описывается отношением , которое представляется множеством строк , принадлежащих декартову произведению .](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e8f/883/fef/e8f883fefd210cb011de4adc628c0880.png \"Figure 1. A table is described by a relation, which is represented as a set of rows , belonging to a Cartesian product .\")\n\n**Figure 1.** A table is described by a [relation](https://en.wikipedia.org/wiki/Relation_\\(database\\))![\\mathbf{R}](https://habrastorage.org/getpro/habr/upload_files/203/6f3/b34/2036f3b3468859de12152bc067e47dac.svg), which is represented as a [set](https://en.wikipedia.org/wiki/Set_\\(mathematics\\)) of [rows](https://en.wikipedia.org/wiki/Row_\\(database\\)) ![\\mathbf{r}](https://habrastorage.org/getpro/habr/upload_files/33d/2a7/97e/33d2a797ee86429db7e38da67483e75f.svg), belonging to a [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) ![\\mathbf{S_1 \\times S_2 \\times \\dots \\times S_n}](https://habrastorage.org/getpro/habr/upload_files/828/aec/1c7/828aec1c78c1359119fc7ccd175da2aa.svg).\n\n**Where:**\n\n-   The [symbol](https://en.wikipedia.org/wiki/Glossary_of_mathematical_symbols) ![\\mathbf{R}](https://habrastorage.org/getpro/habr/upload_files/31f/d32/a0d/31fd32a0d3f4da43190e7cb8a750eb76.svg)denotes a [relation](https://en.wikipedia.org/wiki/Relation_\\(mathematics\\)) ([table](https://en.wikipedia.org/wiki/Table_\\(database\\)));\n    \n-   The [symbol](https://en.wikipedia.org/wiki/Glossary_of_mathematical_symbols) ![\\subseteq](https://habrastorage.org/getpro/habr/upload_files/b9b/ec9/a4e/b9bec9a4e452e6275b2121100862a5b5.svg) indicates that the left side of the [expression](https://en.wikipedia.org/wiki/Expression_\\(mathematics\\)) is a [subset](https://en.wikipedia.org/wiki/Subset) of the right side;\n    \n-   The [symbol](https://en.wikipedia.org/wiki/Glossary_of_mathematical_symbols) ![\\times](https://habrastorage.org/getpro/habr/upload_files/301/5d0/0ff/3015d00ff84b04fc4c65992435fbd09f.svg) denotes the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) of two [sets](https://en.wikipedia.org/wiki/Set_\\(mathematics\\));\n    \n-   The [expression](https://en.wikipedia.org/wiki/Expression_\\(mathematics\\))![\\mathbf{S_n}](https://habrastorage.org/getpro/habr/upload_files/940/b2c/ce2/940b2cce2daa321e8da40ba1da98f586.svg)represents the [domain](https://en.wikipedia.org/wiki/Data_domain), i.e., the [set](https://en.wikipedia.org/wiki/Set_\\(mathematics\\)) of all possible [values](https://en.wikipedia.org/wiki/Value_\\(computer_science\\)) that each [cell](https://en.wikipedia.org/wiki/Table_\\(database\\)) in a [column](https://en.wikipedia.org/wiki/Table_\\(database\\)) can contain.\n    \n\n[Rows](https://en.wikipedia.org/wiki/Row_\\(database\\)), or [elements](https://en.wikipedia.org/wiki/Element_\\(mathematics\\)) of the [relation](https://en.wikipedia.org/wiki/Relation_\\(database\\)) ![\\mathbf{R}](https://habrastorage.org/getpro/habr/upload_files/e84/6f7/61f/e846f761f953c75ff51d3230849758c2.svg), are represented as [n-tuples](https://en.wikipedia.org/wiki/Tuple).\n\n[Data](https://en.wikipedia.org/wiki/Data_\\(computer_science\\)) in the [relational model](https://en.wikipedia.org/wiki/Relational_model) is grouped into [relations](https://en.wikipedia.org/wiki/Relation_\\(database\\)). By using [n-tuples](https://en.wikipedia.org/wiki/Tuple) in this [model](https://en.wikipedia.org/wiki/Database_model), one can precisely represent any conceivable [data structure](https://en.wikipedia.org/wiki/Data_structure), if only we actually ever used [n-tuples](https://en.wikipedia.org/wiki/Tuple) for that. And are [n-tuples](https://en.wikipedia.org/wiki/Tuple) even necessary? For example, every [n-tuple](https://en.wikipedia.org/wiki/Tuple) can be represented as [nested ordered pairs](https://en.wikipedia.org/wiki/Tuple#Tuples_as_nested_ordered_pairs), which suggests that [ordered pairs](https://en.wikipedia.org/wiki/Ordered_pair) alone might be sufficient to represent any [data](https://en.wikipedia.org/wiki/Data_\\(computer_science\\)). Moreover, it’s uncommon for [column](https://en.wikipedia.org/wiki/Table_\\(database\\)) values in [tables](https://en.wikipedia.org/wiki/Table_\\(database\\)) to be represented as [n-tuples](https://en.wikipedia.org/wiki/Tuple) (although, for instance, a [number](https://en.wikipedia.org/wiki/Number) can be [decomposed](https://en.wikipedia.org/wiki/Decomposition_\\(computer_science\\)) into an [n-tuple](https://en.wikipedia.org/wiki/Tuple) of [bits](https://en.wikipedia.org/wiki/Bit)). In some [SQL](https://en.wikipedia.org/wiki/SQL) [databases](https://en.wikipedia.org/wiki/Database), it is even forbidden to use more than ![\\mathbf{32}](https://habrastorage.org/getpro/habr/upload_files/e52/b83/18e/e52b8318e2fc33ea0901c041bc1f2acd.svg) [columns](https://en.wikipedia.org/wiki/Table_\\(database\\)) in a [table](https://en.wikipedia.org/wiki/Table_\\(database\\)) (and, by extension, in its corresponding [n-tuple](https://en.wikipedia.org/wiki/Tuple)). Thus, the actual value of ![\\mathbf{n}](https://habrastorage.org/getpro/habr/upload_files/151/cd6/8ec/151cd68ecf73924d37429c1019914e14.svg) is usually lower than ![\\mathbf{32}](https://habrastorage.org/getpro/habr/upload_files/ded/f66/0ff/dedf660ff7a5b1d8bfa99b90ca0aca67.svg). Therefore, in these cases, there are no [true](https://en.wikipedia.org/wiki/Truth) [n-tuples](https://en.wikipedia.org/wiki/Tuple) — even in modern [relational](https://en.wikipedia.org/wiki/Relational_model) [databases](https://en.wikipedia.org/wiki/Database).\n\n![Рис. 2. Сравнение реляционной модели и ассоциативной модели данных (изначальная модель Саймона Вильямса была упрощена дважды). Иными словами для представления всех данных в реляционной модели требуется множество таблиц под каждый тип данных, в ассоциативной модели как оказалось было достаточно сначала двух таблиц, а потом и вовсе одной таблицы триплетов или дуплетов.](https://habrastorage.org/r/w1560/getpro/habr/upload_files/1ab/e38/6a3/1abe386a353c55b7916bef53e38940ff.png \"Figure 2. Comparison of the relational model and the associative model of data (the original model proposed by Simon Williams was simplified by us twice) [3]. In other words, representing all data in the relational model requires a multitude of tables — one for each data type — whereas in the associative model, it turned out that initially just two tables were sufficient (items and links), and eventually just a single table  (links) of triplet-links or doublet-links was enough.\")\n\n**Figure 2.** Comparison of the [relational model](https://en.wikipedia.org/wiki/Relational_model) and the [associative model of data](http://iacis.org/iis/2009/P2009_1301.pdf) (the original [model](https://en.wikipedia.org/wiki/Data_model) proposed by [Simon Williams](https://www.linkedin.com/in/s1m0n) was simplified by us twice) [\\[3\\]](https://web.archive.org/web/20181219134621/http://sentences.com/docs/amd.pdf). In other words, representing all [data](https://en.wikipedia.org/wiki/Data_\\(computer_science\\)) in the [relational model](https://en.wikipedia.org/wiki/Relational_model) requires a multitude of [tables](https://en.wikipedia.org/wiki/Table_\\(database\\)) — one for each [data type](https://en.wikipedia.org/wiki/Data_type) — whereas in the [associative model](https://web.archive.org/web/20210814063207/https://en.wikipedia.org/wiki/Associative_model_of_data), it turned out that initially just two [tables](https://en.wikipedia.org/wiki/Table_\\(database\\)) were sufficient (`items` and `links`), and eventually just a single [table](https://en.wikipedia.org/wiki/Table_\\(database\\)) (`links`) of [triplet](https://en.wikipedia.org/wiki/Tuple)\\-links or [doublet](https://en.wikipedia.org/wiki/Ordered_pair)\\-links was enough.\n\n### Directed Graph\n\nDirected graphs — and [graphs](https://en.wikipedia.org/wiki/Graph_theory) in general — are based on the concepts of [vertices](https://en.wikipedia.org/wiki/Vertex_\\(graph_theory\\)) and [edges](https://en.wikipedia.org/wiki/Glossary_of_graph_theory#edge) ([2-tuples](https://en.wikipedia.org/wiki/Ordered_pair)).\n\n[A directed graph](https://en.wikipedia.org/wiki/Directed_graph) ![\\mathbf{G}](https://habrastorage.org/getpro/habr/upload_files/2a0/936/873/2a0936873b5fbf6dc6bce2aaabf716f5.svg) is defined as follows:\n\n> ![\\mathbf{G = (V, E), \\quad E \\subseteq V \\times V.}](https://habrastorage.org/getpro/habr/upload_files/fa9/e1f/e8e/fa9e1fe8e000474930ee7d543ebfd8b1.svg) [\\[2\\]](https://books.google.com/books?id=vaXv_yhefG8C)\n\nWhere:\n\n-   ![\\mathbf{V}](https://habrastorage.org/getpro/habr/upload_files/59a/ccb/b8a/59accbb8a95f3e359e9a3738c97d272a.svg) is a [set](https://en.wikipedia.org/wiki/Set_\\(mathematics\\)) whose elements are called [vertices](https://en.wikipedia.org/wiki/Vertex_\\(graph_theory\\)), nodes, or [points](https://en.wikipedia.org/wiki/Point_\\(geometry\\));\n    \n-   ![\\mathbf{E}](https://habrastorage.org/getpro/habr/upload_files/8c1/379/4d2/8c13794d2118caf7d61eb611492c8e75.svg) is a set of [ordered pairs](https://en.wikipedia.org/wiki/Ordered_pair) (2-[tuples](https://en.wikipedia.org/wiki/Tuple)) of [vertices](https://en.wikipedia.org/wiki/Vertex_\\(graph_theory\\)), referred to as arcs, directed [edges](https://en.wikipedia.org/wiki/Glossary_of_graph_theory#edge) (sometimes simply [edges](https://en.wikipedia.org/wiki/Glossary_of_graph_theory#edge)), arrows, or directed [lines segments](https://en.wikipedia.org/wiki/Line_segment).\n    \n\nIn the directed graph model, data is represented by two separate [sets](https://en.wikipedia.org/wiki/Set_\\(mathematics\\)): [nodes](https://en.wikipedia.org/wiki/Vertex_\\(graph_theory\\)) and [edges](https://en.wikipedia.org/wiki/Glossary_of_graph_theory#edge). This [model](https://en.wikipedia.org/wiki/Data_model) can be used to represent almost all [data structures](https://en.wikipedia.org/wiki/Data_structure), except perhaps [sequences](https://en.wikipedia.org/wiki/Sequence) ([n-tuples](https://en.wikipedia.org/wiki/Tuple)). Sometimes, chains of vertices are used to represent sequences. Although this method works, it invariably leads to data duplication, and deduplication in such cases is either complicated or unfeasible. Furthermore, sequences in graphs might be represented by decomposing the [sequence into nested sets](https://en.wikipedia.org/wiki/Tuple#Tuples_as_nested_sets), but in our view, this is not a practical approach. It appears that we are not alone in this belief, which may explain why we have not encountered examples of others employing such method.\n\n![Рис. 3. Сравнение теории графов и теории связей. Вершина эквивалентна замкнутой на себя связи, то есть связи которая в себе начинается и в себе заканчивается. Направленное ребро отображается в направленную связь-дуплет. А ненаправленное ребро отображается в пару направленных связей-дуплетов в обоих направлениях. То есть если в теории графов требуется два типа сущностей - вершины и рёбра, то в теории связей достаточно только связей (больше всего похожих на рёбра).](https://habrastorage.org/r/w1560/getpro/habr/upload_files/932/a13/f5d/932a13f5d90b47e39fb12ff8eaf8a1b3.png \"Figure 3. Comparison of the graph theory and the links theory. A vertex is equivalent to a self-referential link — a link that begins and ends in itself. A directed edge is represented as a directed doublet-links, while an undirected edge is represented as a pair of directed doublet-links in both opposite directions. In other words, while graph theory requires two types of entities — vertices and edges — in the links theory only links (which most closely resemble edges) are necessary.\")\n\n**Figure 3.** Comparison of the graph theory and the links theory. A vertex is equivalent to [a self-referential link](https://linksplatform.github.io/itself.html) — a link that begins and ends in itself. A directed edge is represented as a directed doublet-links, while an undirected edge is represented as a pair of directed doublet-links in both opposite directions. In other words, while graph theory requires two types of entities — vertices and edges — in the links theory only links (which most closely resemble edges) are necessary.\n\n### The links theory\n\nThe links theory is based on the concept of a link.  \n  \nIn the projection of the links theory into set theory, [a link](https://habr.com/ru/companies/deepfoundation/articles/576398) is defined as an [n-tuple](https://en.wikipedia.org/wiki/Tuple) of references to links, which has its own reference that other links can use to refer to it.\n\n> It is worth noting that the separate notion of a reference is required here solely because [circular definitions](https://en.wikipedia.org/wiki/Circular_definition) are not available in set theory. In fact, the links theory can describe itself without needing a distinct term for a reference — in other words, a reference is simply a special case of a link.\n\n#### Duplets\n\nA doublet-link is represented by a duplet (2-tuple or [ordered pair](https://en.wikipedia.org/wiki/Ordered_pair)) of references to links. A doublet-link also has its own reference.\n\n```\nL = { 1 , 2 }\n\nL × L = {\n  (1, 1),\n  (1, 2),\n  (2, 1),\n  (2, 2),\n}\n```\n\n**Where**:\n\n-   ![L](https://habrastorage.org/getpro/habr/upload_files/611/470/8ad/6114708ad83523cef2accb96b6ce0822.svg) is the set of references (from the English word “Links” as in “References”).\n    \n\nIn this example, the set ![L](https://habrastorage.org/getpro/habr/upload_files/606/866/4d6/6068664d6d0540aafbc5cd6e5b00dab2.svg) contains only ![2](https://habrastorage.org/getpro/habr/upload_files/3e0/4b9/0b3/3e04b90b3c0ef9a81cc755b045b55fc4.svg) references to links, namely ![1](https://habrastorage.org/getpro/habr/upload_files/f33/919/ad6/f33919ad6e0a7a03a4eed49345d7554c.svg) and ![2](https://habrastorage.org/getpro/habr/upload_files/b10/5aa/988/b105aa9888806d40465977f0810f3d4b.svg). In other words, in a network of links built on such a set of references, there can be only ![2](https://habrastorage.org/getpro/habr/upload_files/7a1/3d5/400/7a13d540029bf772a37159dc0e1070b6.svg) links.\n\nTo obtain all possible values of a link, [the Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) of ![L](https://habrastorage.org/getpro/habr/upload_files/a58/5e0/6a1/a585e06a14f7587476a496f71943fb06.svg) with itself is used, i.e.,![L \\times L](https://habrastorage.org/getpro/habr/upload_files/091/d67/cf1/091d67cf176a956cd555a9ed6f1f9ad2.svg).\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f23/51b/fe4/f2351bfe4d41eb941faf542197d51163.png \"Figure 4. A matrix representing the Cartesian product of the set {1, 2} with itself. Here we see that links with two references to links can have only 4 possible values.\")\n\n**Figure 4.** A matrix representing the Cartesian product of the set {1, 2} with itself. Here we see that links with two references to links can have only 4 possible values.\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/752/178/3cd/7521783cd0938c6d1f98667963df7467.png \"Figure 5. A table of rows containing all possible variants of link values for a network with two links; these variants are obtained using the Cartesian product of {1, 2} with itself.\")\n\n**Figure 5.** A table of rows containing all possible variants of link values for a network with two links; these variants are obtained using the Cartesian product of {1, 2} with itself.\n\nThe **doublet-links network** is defined as:\n\n> ![\\mathbf{\\lambda: L \\to L \\times L}](https://habrastorage.org/getpro/habr/upload_files/f2c/b3a/9e6/f2cb3a9e6a92e192bfb30aa3ab04c374.svg)\n\nWhere:\n\n-   ![\\to](https://habrastorage.org/getpro/habr/upload_files/b44/f07/bad/b44f07bad2b7ec1faa314c632129e686.svg)denotes [a mapping (function)](https://en.wikipedia.org/wiki/Function_\\(mathematics\\));\n    \n-   ![\\mathbf{\\lambda}](https://habrastorage.org/getpro/habr/upload_files/35c/a66/527/35ca66527c3493632880e4df4e5a76b0.svg) represents the function that defines the duplet-links network;\n    \n-   ![\\mathbf{L}](https://habrastorage.org/getpro/habr/upload_files/102/766/32a/10276632ae4bfa07367daf235a73c68c.svg) denotes the set of references to links.\n    \n\n**Example**:\n\n> ![1 \\to (1, 1)](https://habrastorage.org/getpro/habr/upload_files/e20/117/3ee/e201173eeb4173dad6b5d088650dd2d0.svg)\n> \n> ![2 \\to (2, 2)](https://habrastorage.org/getpro/habr/upload_files/bd6/77c/115/bd677c1155f209d676352169d3816f78.svg)\n> \n> ![\\mathbf{3 \\to (1, 2)}](https://habrastorage.org/getpro/habr/upload_files/bd1/42a/295/bd142a295ff649cac225e73f1ec6992a.svg)\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/87a/8a4/914/87a8a49142aa21abf813634df99f478c.png \"Figure 6. A network of three links. The representation of the duplet‑links network resembles a graph, but we refer to this visualization as a network of links. The first and second links have a similar structure — that is, both begin from themselves and end in themselves. As a result, instead of the traditional depiction of a vertex as a point in graph theory, we get a graphical representation of a closed self‑referential arrow that resembles an infinity symbol.\")\n\n**Figure 6. A network of three links.** The representation of the duplet‑links network resembles a graph, but we refer to this visualization as a network of links. The first and second links have a similar structure — that is, both begin from themselves and end in themselves. As a result, instead of the traditional depiction of a vertex as a point in graph theory, we get a graphical representation of a closed self‑referential arrow that resembles an infinity symbol.\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a45/b25/979/a45b25979018b0847a1cf3ae1e34df60.png \"Figure 7. This is a graphical representation of the Cartesian product in the form of a matrix, which displays all possible link values. The links that define a specific network are highlighted in orange. In other words, out of 9 possible link value variants, only 3 links are selected, corresponding to the size of the set L.\")\n\n**Figure 7.** This is a graphical representation of the Cartesian product in the form of a matrix, which displays all possible link values. The links that define a specific network are highlighted in orange. In other words, out of 9 possible link value variants, only 3 links are selected, corresponding to the size of the set **L**.\n\nA network of doublet-links can represent any data structure.\n\nFor example, doublet-links can:\n\n-   Link an object with its properties;\n    \n-   Connect two links together, which is something graph theory definition does not allow;\n    \n-   Represent any sequence (n-tuple) as a tree built from nested ordered pairs;\n    \n-   Describe a natural language sentence, for instance, using a [subject-predicate](https://en.wikipedia.org/wiki/Predicate_\\(grammar\\)) linguistics model.\n    \n\nThanks to this and other facts, we believe that doublet-links can represent any conceivable data structure.\n\n#### Triplets\n\nA triplet-link is represented by a triplet (3-tuple) of references to links.\n\n```\nL = { 1 , 2 }\n\nL × L = {\n  (1, 1),\n  (1, 2),\n  (2, 1),\n  (2, 2),\n}\n\nL × L × L = {\n  (1, 1, 1),\n  (1, 1, 2),\n  (1, 2, 1),\n  (1, 2, 2),\n  (2, 1, 1),\n  (2, 1, 2),\n  (2, 2, 1),\n  (2, 2, 2),\n}\n```\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/43c/8b1/b36/43c8b1b36ce92b6cf1cf2b402efd95d8.png \"Figure 8. A three-dimensional cube-matrix that represents all possible values of a triplet-link. Such a cube is obtained by recursively taking the Cartesian product of the set {1, 2} with itself, i.e., { 1, 2 } × { 1, 2 } × { 1, 2 }.\")\n\n**Figure 8.** A three-dimensional cube-matrix that represents all possible values of a triplet-link. Such a cube is obtained by recursively taking the Cartesian product of the set {1, 2} with itself, i.e., { 1, 2 } × { 1, 2 } × { 1, 2 }.\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ca2/b5e/f9c/ca2b5ef9c0d0989a2ba8a8d4f097f184.png \"Figure 9. A table of all possible variants of triplet-link values that can be obtained by taking the Cartesian product of the set { 1, 2 } with itself recursively, i.e., { 1, 2 } × { 1, 2 } × { 1, 2 }. Note: The first reference can be interpreted as the beginning, the second as the type, and the third as the end; the user determines how to interpret the components of the reference vector in accordance with the task at hand.\")\n\n**Figure 9.** A table of all possible variants of triplet-link values that can be obtained by taking the Cartesian product of the set { 1, 2 } with itself recursively, i.e., { 1, 2 } × { 1, 2 } × { 1, 2 }. **Note:** The first reference can be interpreted as the beginning, the second as the type, and the third as the end; the user determines how to interpret the components of the reference vector in accordance with the task at hand.\n\nA **triplet links network** is defined as:\n\n> ![\\mathbf{\\lambda : L \\to L \\times L \\times L}](https://habrastorage.org/getpro/habr/upload_files/c51/7e2/87d/c517e287d2a7d79c2b935cd4e973523a.svg)\n\nWhere:\n\n-   ![\\mathbf{\\lambda}](https://habrastorage.org/getpro/habr/upload_files/2de/458/b3f/2de458b3fcb130fb1d0643151ef8037d.svg) denotes the function that defines the triplet links network;\n    \n-   ![\\mathbf{L}](https://habrastorage.org/getpro/habr/upload_files/e92/594/55f/e9259455f97666907efd09c7ced3d127.svg) denotes the set of references to links.\n    \n\nExample of a function specifying a particular triplet links network:\n\n> ![1 \\to (1, 1, 1)](https://habrastorage.org/getpro/habr/upload_files/e5b/d73/c80/e5bd73c8055d79fe139111aa2a55e67a.svg)\n> \n> ![2 \\to (2, 2, 2)](https://habrastorage.org/getpro/habr/upload_files/07d/19d/68a/07d19d68a950f6fbda8f7c8ad162a03f.svg)\n> \n> ![3 \\to (3, 3, 3)](https://habrastorage.org/getpro/habr/upload_files/48c/e97/ca3/48ce97ca3af3d696ca20be41b206b371.svg)\n> \n> ![\\mathbf{4 \\to (1, 2, 3)}](https://habrastorage.org/getpro/habr/upload_files/a8f/daf/402/a8fdaf4021ef03e2c46d781083b219b2.svg)\n\n![alt text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/76c/672/576/76c6725766a17ea75ebed8e99abd070e.jpeg \"Figure 10. An associative triplet network represented as a colored directed graph. In this associative network, there are 4 triplet-links corresponding to the function defined above. The nodes correspond to links, and the edge colors correspond to references to links as shown in Figure 9 (red – from, blue – type, green – to).\")\n\n**Figure 10.** An associative triplet network represented as a colored directed graph. In this associative network, there are 4 triplet-links corresponding to the function defined above. The nodes correspond to links, and the edge colors correspond to references to links as shown in Figure 9 (red – from, blue – type, green – to).\n\nTriplet-links can perform the same functions as doublet-links. Since triplet-links include an additional reference, that extra element can, for example, be used to indicate the type of link.\n\nFor instance, triplet-links can:\n\n-   Link an object, its property, and its value;\n    \n-   Link two links together using a defined relation;\n    \n-   Describe a natural language sentence, for example, using a [subject-verb-object](https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object_word_order) model.\n    \n\n#### Sequences\n\nA sequence of link references — also known as an [n-tuple](https://en.wikipedia.org/wiki/Tuple) — are the general case. \n\nIn general, a links network is defined as:\n\n> ![\\mathbf{\\lambda : L \\rightarrow \\underbrace{ L \\times L \\times \\ldots \\times L}_{n}}](https://habrastorage.org/getpro/habr/upload_files/5c7/f16/636/5c7f1663641976ee66d0f70703967ef6.svg)\n\nWhere:\n\n-   The ![\\mathbf{\\lambda}](https://habrastorage.org/getpro/habr/upload_files/b2a/298/365/b2a2983658ac09d0fcd4f92eec2b7736.svg) symbol denotes the function that defines the links network;\n    \n-   The ![\\mathbf{L}](https://habrastorage.org/getpro/habr/upload_files/4c9/a5d/cc5/4c9a5dcc5d8c83fdc93af35cf54f0f36.svg) symbol denotes the set of link references.\n    \n\nExample:\n\n> ![1 \\to (1)](https://habrastorage.org/getpro/habr/upload_files/be3/043/b11/be3043b119b494fff27df2bd70b5f955.svg)\n> \n> ![2 \\to (2, 2)](https://habrastorage.org/getpro/habr/upload_files/318/829/e3c/318829e3ceaf6ea333f3ab9e248426c2.svg)\n> \n> ![3 \\to (3, 3, 3)](https://habrastorage.org/getpro/habr/upload_files/390/88e/cb1/39088ecb103b398d3eb81ba270bbf089.svg)\n> \n> ![\\mathbf{4 \\to (1, 2, 3, 2, 1)}](https://habrastorage.org/getpro/habr/upload_files/044/ec4/584/044ec45845d69ce2ab702ba7db156212.svg)\n\nIn this example, n-tuples of variable lengths are used as link's values.  \n  \nSequences (vectors) are, in essence, equivalent in expressive power to the relational model — a fact that remains to be proven within the developing theory. However, once we observed that doublet-links and triplet-links are sufficient for representing sequences of any size, we hypothesized that there is no need to use sequences directly as they representable by double-links.\n\n### Comparison summary\n\nThe [relational data model](https://en.wikipedia.org/wiki/Relational_model) can represent everything — even [the associative model](https://web.archive.org/web/20210814063207/https://en.wikipedia.org/wiki/Associative_model_of_data), but to do so [well-ordering](https://en.wikipedia.org/wiki/Well-order) must be introduced, which usually comes in a form of separate ID column. As the relational data model is based on notion of [set](https://en.wikipedia.org/wiki/Set_\\(mathematics\\)) instead of a [sequence](https://en.wikipedia.org/wiki/Sequence). In contrast, the graph model excels at representing relationships, but is less effective at representing unique deduplicated sequences.  \n  \nAlthough the relational model itself doesn’t require data to be split across several tables, traditional implementations typically adopt that approach with fixed schemas, which leads to fragmentation of related data and complicates the reconstruction of inherent relationships. In contrast, the associative model employs a unified links storage that achieves the highest possible degree of normalization. This design simplifies the one-to-one mapping of the business domain, thereby easing rapid requirement changes [\\[4\\]](https://www.researchgate.net/publication/255670856_A_COMPARISON_OF_THE_RELATIONAL_DATABASE_MODEL_AND_THE_ASSOCIATIVE_DATABASE_MODEL).\n\nThe associative model can easily represent n-tuples of unlimited length using tuples with ![\\mathbf{n \\geq 2}](https://habrastorage.org/getpro/habr/upload_files/b29/c29/6e9/b29c296e9caa29140c03d5ec5fa2da0d.svg). It is as capable as graph theory in representing associations and as powerful as the relational model, being able to fully represent any SQL table. Additionally, the associative model can represent strict sequences, allowing any sequence to be encapsulated in a unique single link, which is beneficial for deduplication.\n\nIn the relational model, only one relation is needed to mimic the behavior of the associative model, and typically no more than 2–3 columns are required aside from an explicit ID or built-in row ID. The ID itself is required in relational model because it is built up on concept of set, for the contrast the links theory builds up on concept of sequence thus explicit ID is not required (and can optionally added if user really needs it).\n\nBy definition, the graph model cannot directly create an edge between edges. Thus, it would need either a redefinition or an extension with an unambiguous method for storing unique deduplicated sequences. While sequences might be stored as [nested sets](https://en.wikipedia.org/wiki/Tuple#Tuples_as_nested_sets) within the graph model, this approach is not popular. Although the graph model is closest to doublet-links, it still differs by definition.\n\nUsing the associative model means there is no longer a need to choose between SQL and NoSQL databases; instead, an associative data store can represent everything in the simplest possible way, with data always kept in its form closest to the original (usually this the normalized form, but denormalization also possible if needed).\n\n## Mathematical introduction to the links theory\n\n### Introduction\n\nNow that we have briefly introduced the origins of our work, it is time to delve deeper into the theory.\n\n> The links theory is being developed as a more fundamental framework compared to set theory or type theory, and as a replacement for relational algebra and graph theory as unifying theory. While type theory is built upon the basic notions of “type” and “term”, and set theory on “set” and “element”, the links theory reduces everything to the single concept of a “link”.\n\nIn this section, we will explain the core concepts and terminology used in the links theory.  \n  \nWe will then present the definitions of the links theory within the framework of set theory, and subsequently project these definitions into type theory using the interactive theorem prover Coq.\n\nFinally, we will summarize our findings and outline directions for further research and development of the links theory.\n\n#### The links theory\n\nAt the heart of the links theory lies the unified concept of a link. The additional notion of a reference to a link is introduced only for theories that do not support circular definitions — such as set theory and type theory.\n\n#### Link\n\nA link possesses an asymmetrical recursive (fractal) structure, which can be simply expressed as: a link **links** links (as in “a link **connects** links”). The term “asymmetrical” refers to the fact that every link has a direction — from its source (beginning) to its destination (end).\n\n### The links theory definitions within set theory framework\n\nA **reference to a vector** is a unique identifier or ordinal number, which is associated with a specific vector representing a sequence of references to other vectors.\n\nSet of references to vectors:\n\n> ![\\mathbf{L ⊆ ℕ_0}](https://habrastorage.org/getpro/habr/upload_files/d4b/359/be0/d4b359be04ab5657f765a2ac88cc87ed.svg)\n\nA **vector of references** is a vector consisting of zero or more references to vectors, where the number of references corresponds to the number of elements in the vector.\n\nSet of all vectors of references of length ![n ∈ ℕ_0](https://habrastorage.org/getpro/habr/upload_files/d34/892/f89/d34892f89cd830e7b2f50691061d6782.svg):\n\n> ![\\mathbf{V_n = L^n}](https://habrastorage.org/getpro/habr/upload_files/e85/8b7/ef4/e858b7ef4aa8f53c89dba3da5d719167.svg)\n\nThe Cartesian power ![L^n](https://habrastorage.org/getpro/habr/upload_files/8e6/a4e/352/8e6a4e352b6dc6a114223e80ac72c2d1.svg) always produces a vector of length ![n](https://habrastorage.org/getpro/habr/upload_files/81d/8f6/881/81d8f6881171ec6b4c77a12c6c4a66db.svg) , since all its components are of the same type ![L](https://habrastorage.org/getpro/habr/upload_files/69e/b3e/52d/69eb3e52d0d10df194e08ac1c8fb62fd.svg).  \nIn other words, ![L^n](https://habrastorage.org/getpro/habr/upload_files/8e6/a4e/352/8e6a4e352b6dc6a114223e80ac72c2d1.svg) represents the set of all possible n-element vectors (essentially n‑tuples), in which every element belongs to the set ![L](https://habrastorage.org/getpro/habr/upload_files/58f/85a/448/58f85a448ce12693a88e51a74cbd355a.svg).\n\nAn **association** is an ordered pair consisting of a reference to a vector and a vector of references. This structure serves as a mapping between references and vectors.\n\n> ![\\mathbf{A = L \\times V_n}](https://habrastorage.org/getpro/habr/upload_files/9de/747/627/9de747627c4584713bb01bdbe9a56445.svg)\n\nAn **associative network** of vectors of length **n** (or an n-dimensional associative network) is defined by a family of functions ![\\{anetv^n\\}](https://habrastorage.org/getpro/habr/upload_files/4a2/dbe/629/4a2dbe6291659f4a865fa3abf3057490.svg), where each function![anetv^n: L → V_n](https://habrastorage.org/getpro/habr/upload_files/557/ff0/dcf/557ff0dcf80e5e51412557f3e4643c99.svg) maps a reference ![l ∈ L](https://habrastorage.org/getpro/habr/upload_files/df1/fad/127/df1fad127ed0e2ae108b855e4daf3786.svg) to a vector of references of length ![n](https://habrastorage.org/getpro/habr/upload_files/a90/9c5/e4a/a909c5e4aacb8a775f9c0035834441c3.svg), belonging to ![V_n](https://habrastorage.org/getpro/habr/upload_files/c88/daf/d7f/c88dafd7f5e1e21e63cbfcb3785550b9.svg), thereby identifying points in an n-dimensional space.  \n![n](https://habrastorage.org/getpro/habr/upload_files/a90/9c5/e4a/a909c5e4aacb8a775f9c0035834441c3.svg) in ![anetv^n](https://habrastorage.org/getpro/habr/upload_files/5ba/f2d/c68/5baf2dc683c8181e277f46b8b64c4869.svg) indicates that the function returns vectors containing ![n](https://habrastorage.org/getpro/habr/upload_files/a90/9c5/e4a/a909c5e4aacb8a775f9c0035834441c3.svg) references. Each n-dimensional associative network thus represents a sequence of points in n-dimensional space.\n\n**Family of functions:**\n\n> ![\\mathbf{∪_f \\{anetv^n | n ∈ ℕ_0\\} ⊆ A}](https://habrastorage.org/getpro/habr/upload_files/d4b/c6a/643/d4bc6a643fd9587a897fe742e42c0b2a.svg)\n\nHere, the union symbol ![∪_f](https://habrastorage.org/getpro/habr/upload_files/649/13d/c54/64913dc54812a2ab04e153c0139d7ba6.svg) denotes the aggregation of all functions in the family ![\\{anetv^n\\}](https://habrastorage.org/getpro/habr/upload_files/9a2/54f/2e0/9a254f2e0bfb7cf5b9d2d49a90a09eba.svg), and the symbol  ![ ⊆](https://habrastorage.org/getpro/habr/upload_files/e00/ca1/186/e00ca1186f521ffff0257256f5259d18.svg) indicates that these ordered pairs — viewed as functional binary relations —are a subset of the set ![A](https://habrastorage.org/getpro/habr/upload_files/406/c21/65d/406c2165d8c7ee7f53a19daf3ebcad54.svg) of all associations.\n\n**Set of duplets (ordered pairs or 2-dimensional vectors) of references:**\n\n> ![\\mathbf{D = L^2}](https://habrastorage.org/getpro/habr/upload_files/fe0/558/c19/fe0558c1937f1af0e5e1d4775a5e3459.svg)\n\nThis is the set of all duplets ![(L, L)](https://habrastorage.org/getpro/habr/upload_files/6da/4d3/3c6/6da4d33c6ac154e1494a7697bab1fb8c.svg), i.e., the second Cartesian power of ![L](https://habrastorage.org/getpro/habr/upload_files/a0b/4c1/a49/a0b4c1a4959102f4227ab510a22c1781.svg) .\n\n**Associative network of duplets (or a 2-dimensional associative network):**\n\n> ![\\mathbf{anetd: L → L^2}](https://habrastorage.org/getpro/habr/upload_files/43d/47c/c8d/43d47cc8d060c4e0eb17153e2a24753d.svg)\n\nEach associative network of duplets thus represents a sequence of points in a two‑dimensional space.  \n  \nAn empty vector (vector of length zero) is represented by the empty tuple, denoted as ![()](https://habrastorage.org/getpro/habr/upload_files/6e3/86c/822/6e386c8222f479f1f9adb78524e078c7.svg) or ![∅](https://habrastorage.org/getpro/habr/upload_files/0a7/742/e37/0a7742e378e2661a73fa374b8e7aa620.svg).\n\n**Associative network of nested ordered pairs:**\n\n> ![\\mathbf{anetl: L → NP}\\textbf{, where }\\mathbf{NP = \\{(∅, ∅) | (l, np), l ∈ L, np ∈ NP\\} }](https://habrastorage.org/getpro/habr/upload_files/6da/35e/ea5/6da35eea526805df88de52922e627614.svg)\n\n![NP](https://habrastorage.org/getpro/habr/upload_files/aff/e3c/dcd/affe3cdcd5b32d4b11da1d3bbbf92950.svg) is the set of nested ordered pairs consisting of empty pairs and pairs containing one or more elements. In this way, a vector of length ![n \\in \\mathbb{N}_0](https://habrastorage.org/getpro/habr/upload_files/9fa/a5a/aab/9faa5aaab28e48372a299c0c80da2fcd.svg) can be represented as nested ordered pairs.\n\n### Projection of the links theory into type theory (coq) via set theory\n\n#### About Coq\n\n[Coq](https://ru.wikipedia.org/wiki/Coq) is an interactive theorem prover based on higher-order type theory, also known as the Calculus of Inductive Constructions (CIC). It is a powerful environment for formalizing complex mathematical theorems, checking proofs for correctness, and extracting executable code from formally verified specifications. Coq is widely used both in academia for the formalization of mathematics and in the IT industry for the verification of software and hardware.\n\nThe decision to use Coq to describe the links theory within type theory was driven by the need for rigorous formalization of proofs and assurance of logical correctness during the development of the links theory. Coq enables the precise expression of properties and operations on links through its robust type system and advanced proof mechanisms.\n\nIn anticipation of extensive work aimed at proving the equivalence of the relational model and the associative network of doublets, this section presents the initial steps undertaken using the Coq proof system. In the first phase, our goal is to formalize the structures of associative networks by defining the basic types, functions, and structures within Coq.\n\n#### Definitions of associative networks\n\n[\\[Link to source code\\]](https://github.com/deep-foundation/deep-theory/blob/main/associative_proofs/coq/ANetDefs.v)\n\n```\nRequire Import PeanoNat.\nRequire Import Coq.Init.Nat.\nRequire Import Vector.\nRequire Import List.\nRequire Import Coq.Init.Datatypes.\nImport ListNotations.\nImport VectorNotations.\n\n(* Set of vector references: L ⊆ ℕ₀ *)\nDefinition L := nat.\n\n(* Default value for L: zero *)\nDefinition LDefault : L := 0.\n\n(* Set of vectors of references of length n ∈ ℕ₀: Vn ⊆ Lⁿ *)\nDefinition Vn (n : nat) := t L n.\n\n(* Default value for Vn *)\nDefinition VnDefault (n : nat) : Vn n := Vector.const LDefault n.\n\n(* Set of all associations: A = L × Vn *)\nDefinition A (n : nat) := prod L (Vn n).\n\n(* Associative network of vectors of length n (or n-dimensional associative network) from the family of functions {anetvⁿ : L → Vn} *)\nDefinition ANetVf (n : nat) := L -> Vn n.\n\n(* Associative network of vectors of length n (or n-dimensional associative network) as a sequence *)\nDefinition ANetVl (n : nat) := list (Vn n).\n\n(* Nested ordered pairs *)\nDefinition NP := list L.\n\n(* Associative network of nested ordered pairs: anetl : L → NP *)\nDefinition ANetLf := L -> NP.\n\n(* Associative network of nested ordered pairs as a sequence of nested ordered pairs *)\nDefinition ANetLl := list NP.\n\n(* Duplet of references *)\nDefinition D := prod L L.\n\n(* Default value for D: a pair of two LDefault values, used to denote an empty duplet *)\nDefinition DDefault : D := (LDefault, LDefault).\n\n(* Associative network of duplets (or two-dimensional associative network): anetd : L → L² *)\nDefinition ANetDf := L -> D.\n\n(* Associative network of duplets (or two-dimensional associative network) as a sequence of duplets *)\nDefinition ANetDl := list D.\n```\n\n#### Functions for converting associative network\n\n```\n(* Function to convert Vn to NP *)\nFixpoint VnToNP {n : nat} (v : Vn n) : NP :=\n  match v with\n  | Vector.nil _ => List.nil\n  | Vector.cons _ h _ t => List.cons h (VnToNP t)\n  end.\n\n(* Function to convert ANetVf to ANetLf *)\nDefinition ANetVfToANetLf {n : nat} (a: ANetVf n) : ANetLf :=\n  fun id => VnToNP (a id).\n\n(* Function to convert ANetVl to ANetLl *)\nDefinition ANetVlToANetLl {n: nat} (net: ANetVl n) : ANetLl :=\n  map VnToNP net.\n\n(* Function to convert NP to Vn, returning an option *)\nFixpoint NPToVnOption (n: nat) (p: NP) : option (Vn n) :=\n  match n, p with\n  | 0, List.nil => Some (Vector.nil nat)\n  | S n', List.cons f p' => \n      match NPToVnOption n' p' with\n      | None => None\n      | Some t => Some (Vector.cons nat f n' t)\n      end\n  | _, _ => None\n  end.\n\n(* Function to convert NP to Vn using VnDefault *)\nDefinition NPToVn (n: nat) (p: NP) : Vn n :=\n  match NPToVnOption n p with\n  | None => VnDefault n\n  | Some t => t\n  end.\n\n(* Function to convert ANetLf to ANetVf *)\nDefinition ANetLfToANetVf { n: nat } (net: ANetLf) : ANetVf n :=\n  fun id => match NPToVnOption n (net id) with\n            | Some t => t\n            | None => VnDefault n\n            end.\n\n(* Function to convert ANetLl to ANetVl *)\nDefinition ANetLlToANetVl {n: nat} (net : ANetLl) : ANetVl n :=\n  map (NPToVn n) net.\n\n(* Function to convert NP to ANetDl with an index offset *)\nFixpoint NPToANetDl_ (offset: nat) (np: NP) : ANetDl :=\n  match np with\n  | nil => nil\n  | cons h nil => cons (h, offset) nil\n  | cons h t => cons (h, S offset) (NPToANetDl_ (S offset) t)\n  end.\n\n(* Function to convert NP to ANetDl *)\nDefinition NPToANetDl (np: NP) : ANetDl := NPToANetDl_ 0 np.\n\n(* Function to append NP to the tail of ANetDl *)\nDefinition AddNPToANetDl (anet: ANetDl) (np: NP) : ANetDl :=\n  app anet (NPToANetDl_ (length anet) np).\n\n(* Function that removes the head of anetd and returns the tail starting at offset *)\nFixpoint ANetDl_behead (anet: ANetDl) (offset : nat) : ANetDl :=\n  match offset with\n  | 0 => anet\n  | S n' =>\n    match anet with\n    | nil => nil\n    | cons h t => ANetDl_behead t n'\n    end\n  end.\n\n(* Function to convert ANetDl to NP with indexing starting at the beginning of ANetDl from offset *)\nFixpoint ANetDlToNP_ (anet: ANetDl) (offset: nat) (index: nat): NP :=\n  match anet with\n  | nil => nil\n  | cons (x, next_index) tail_anet =>\n    if offset =? index then\n      cons x (ANetDlToNP_ tail_anet (S offset) next_index)\n    else\n      ANetDlToNP_ tail_anet (S offset) index\n  end.\n\n(* Function to read NP from ANetDl by the duplet index *)\nDefinition ANetDl_readNP (anet: ANetDl) (index: nat) : NP :=\n  ANetDlToNP_ anet 0 index.\n\n(* Function to convert ANetDl to NP starting from the head of the anet list *)\nDefinition ANetDlToNP (anet: ANetDl) : NP := ANetDl_readNP anet 0.\n\n(*\n  Now everything is ready for converting the associative network of nested ordered pairs anetl : L → NP\n  into the associative network of duplets anetd : L → L².\n  \n  This conversion can be done in different ways: either preserving the original references to vectors\n  or with reindexing. Reindexing can be omitted if one writes an additional function for the duplet associative network\n  that returns the nested ordered pair by its reference.\n*)\n\n(* Function to add ANetLl to ANetDl *)\nFixpoint AddANetLlToANetDl (anetd: ANetDl) (anetl: ANetLl) : ANetDl :=\n  match anetl with\n  | nil => anetd\n  | cons h t => AddANetLlToANetDl (AddNPToANetDl anetd h) t\n  end.\n\n(* Function to convert ANetLl to ANetDl *)\nDefinition ANetLlToANetDl (anetl: ANetLl) : ANetDl :=\n  match anetl with\n  | nil => nil\n  | cons h t => AddANetLlToANetDl (NPToANetDl h) t\n  end.\n\n(* Function to find NP in the tail of ANetDl starting at offset by its ordinal number.\n   Returns the NP offset. *)\nFixpoint ANetDl_offsetNP_ (anet: ANetDl) (offset: nat) (index: nat) : nat :=\n  match anet with\n  | nil => offset + (length anet)\n  | cons (_, next_index) tail_anet =>\n    match index with\n    | O => offset\n    | S index' => \n      if offset =? next_index then\n        ANetDl_offsetNP_ tail_anet (S offset) index'\n      else\n        ANetDl_offsetNP_ tail_anet (S offset) index\n    end\n  end.\n\n(* Function to find NP in ANetDl by its ordinal number.\n   Returns the NP offset. *)\nDefinition ANetDl_offsetNP (anet: ANetDl) (index: nat) : nat :=\n  ANetDl_offsetNP_ anet 0 index.\n\n(* Function to convert ANetVl to ANetDl *)\nDefinition ANetVlToANetDl {n : nat} (anetv: ANetVl n) : ANetDl :=\n  ANetLlToANetDl (ANetVlToANetLl anetv).\n\n(*\n  Now everything is ready for converting the duplet associative network anetd : L → L²\n  into the associative network of nested ordered pairs anetl : L → NP.\n  \n  We will perform this conversion while preserving the original references to vectors.\n  Reindexing can be omitted because there is the function ANetDl_offsetNP for the duplet associative network\n  that returns the offset of the nested ordered pair by its reference.\n*)\n\n(* Function that removes the first NP from ANetDl and returns the tail *)\nFixpoint ANetDl_beheadNP (anet: ANetDl) (offset: nat) : ANetDl :=\n  match anet with\n  | nil => nil\n  | cons (_, next_index) tail_anet =>\n    if offset =? next_index then (* end of NP *)\n      tail_anet\n    else  (* NP not ended yet *)\n      ANetDl_beheadNP tail_anet (S offset)\n  end.\n\n(* Function to convert NP and ANetDl with an offset into ANetLl *)\nFixpoint ANetDlToANetLl_ (anetd: ANetDl) (np: NP) (offset: nat) : ANetLl :=\n  match anetd with\n  | nil => nil (* discard NP even if incomplete *)\n  | cons (x, next_index) tail_anet =>\n    if offset =? next_index then (* end of NP, move to the next NP *)\n      cons (app np (cons x nil)) (ANetDlToANetLl_ tail_anet nil (S offset))\n    else  (* NP not finished yet, continue parsing the duplet network *)\n      ANetDlToANetLl_ tail_anet (app np (cons x nil)) (S offset)\n  end.\n\n(* Function to convert ANetDl to ANetLl *)\nDefinition ANetDlToANetLl (anetd: ANetDl) : ANetLl :=\n  ANetDlToANetLl_ anetd nil LDefault.\n```\n\n#### Predicates of equivalence for associative networks\n\n```\n(* The definition ANetVf_equiv introduces a predicate for the equivalence of two associative networks of vectors of length n,\n   anet1 and anet2 of type ANetVf.\n\n   This predicate describes the property of \"equivalence\" for such networks.\n   It asserts that anet1 and anet2 are considered \"equivalent\" if, for every reference id, the vector associated with id in anet1\n   exactly matches the vector associated with the same id in anet2.\n*)\nDefinition ANetVf_equiv {n: nat} (anet1: ANetVf n) (anet2: ANetVf n) : Prop :=\n  forall id, anet1 id = anet2 id.\n\n(* The definition ANetVl_equiv_Vl introduces a predicate for the equivalence of two associative networks of vectors of length n,\n   anet1 and anet2 of type ANetVl.\n*)\nDefinition ANetVl_equiv_Vl {n: nat} (anet1: ANetVl n) (anet2: ANetVl n) : Prop :=\n  anet1 = anet2.\n\n(* Equivalence predicate for associative networks of duplets ANetDf *)\nDefinition ANetDf_equiv (anet1: ANetDf) (anet2: ANetDf) : Prop := forall id, anet1 id = anet2 id.\n\n(* Equivalence predicate for associative networks of duplets ANetDl *)\nDefinition ANetDl_equiv (anet1: ANetDl) (anet2: ANetDl) : Prop := anet1 = anet2.\n```\n\n#### Lemmas of equivalence of associative networks\n\n```\n(* Lemma on preservation of vector length in the associative network *)\nLemma Vn_dim_preserved : forall {l: nat} (t: Vn l), List.length (VnToNP t) = l.\nProof.\n  intros l t.\n  induction t.\n  - simpl. reflexivity.\n  - simpl. rewrite IHt. reflexivity.\nQed.\n\n\n(* Lemma on the mutual inversion of the functions NPToVnOption and VnToNP\n\n   H_inverse proves that every Vn vector can be converted losslessly to an NP\n   using VnToNP and then back to Vn using NPToVnOption.\n\n   Formally, forall n: nat, forall t: Vn n, NPToVnOption n (VnToNP t) = Some t states that\n   for every natural number n and each Vn vector of length n,\n   we can convert Vn to NP using VnToNP,\n   then convert the result back to Vn using NPToVnOption n,\n   and ultimately obtain the same Vn vector we started with.\n\n   This property is very important because it guarantees that these two functions\n   form an inverse pair on the set of convertible vectors Vn and NP.\n   When you apply both functions to values in this set, you end up with the original value.\n   This means that no information is lost during the transformations,\n   so you can freely convert between Vn and NP as required in implementations or proofs.\n*)\nLemma H_inverse: forall n: nat, forall t: Vn n, NPToVnOption n (VnToNP t) = Some t.\nProof.\n  intros n.\n  induction t as [| h n' t' IH].\n  - simpl. reflexivity.\n  - simpl. rewrite IH. reflexivity.\nQed.\n\n\n(*\n   The Wrapping and Recovery Theorem for the Associative Network of Vectors:\n\n   Let an associative network of vectors of length n be given, denoted as anetvⁿ : L → Vⁿ.\n   Define an operation that maps this network to the associative network of nested ordered pairs anetl : L → NP,\n   where NP = {(∅,∅) | (l, np), l ∈ L, np ∈ NP}.\n   Then define the inverse mapping from the associative network of nested ordered pairs back to the associative network of vectors of length n.\n\n   The theorem states:\n\n   For any associative network of vectors of length n, anetvⁿ, applying the transformation to the associative network\n   of nested ordered pairs and then the inverse transformation back to the associative network of vectors of length n\n   recovers the original network anetvⁿ.\n   In other words:\n\n       ∀ anetvⁿ : L → Vⁿ, inverse(forward(anetvⁿ)) = anetvⁿ.\n*)\nTheorem anetf_equiv_after_transforms : forall {n: nat} (anet: ANetVf n),\n  ANetVf_equiv anet (fun id => match NPToVnOption n ((ANetVfToANetLf anet) id) with\n                            | Some t => t\n                            | None   => anet id\n                            end).\nProof.\n  intros n net id.\n  unfold ANetVfToANetLf.\n  simpl.\n  rewrite H_inverse.\n  reflexivity.\nQed.\n\n\n(* Lemma on preservation of the length of NP lists in the duplet associative network *)\nLemma NP_dim_preserved : forall (offset: nat) (np: NP), \n    length np = length (NPToANetDl_ offset np).\nProof.\n  intros offset np.\n  generalize dependent offset. \n  induction np as [| n np' IHnp']; intros offset.\n  - simpl. reflexivity.\n  - destruct np' as [| m np'']; simpl; simpl in IHnp'.\n    + reflexivity.\n    + rewrite IHnp' with (offset := S offset). reflexivity.\nQed.\n```\n\n#### Examples of conversions between associative networks\n\n```\n(* Notation for list notation *)\nNotation \"{ }\" := (nil) (at level 0).\nNotation \"{ x , .. , y }\" := (cons x .. (cons y nil) ..) (at level 0).\n\n(* Three-dimensional associative network *)\nDefinition complexExampleNet : ANetVf 3 :=\n  fun id => match id with\n  | 0 => [0; 0; 0]\n  | 1 => [1; 1; 2]\n  | 2 => [2; 4; 0]\n  | 3 => [3; 0; 5]\n  | 4 => [4; 1; 1]\n  | S _ => [0; 0; 0]\n  end.\n\n(* Vectors of references *)\nDefinition exampleTuple0 : Vn 0 := [].\nDefinition exampleTuple1 : Vn 1 := [0].\nDefinition exampleTuple4 : Vn 4 := [3; 2; 1; 0].\n\n(* Conversion of vectors of references into nested ordered pairs (lists) *)\nDefinition nestedPair0 := VnToNP exampleTuple0.\nDefinition nestedPair1 := VnToNP exampleTuple1.\nDefinition nestedPair4 := VnToNP exampleTuple4.\n\nCompute nestedPair0.  (* Expected result: { } *)\nCompute nestedPair1.  (* Expected result: {0} *)\nCompute nestedPair4.  (* Expected result: {3, 2, 1, 0} *)\n\n(* Computing the values of the converted function of the three-dimensional associative network *)\nCompute (ANetVfToANetLf complexExampleNet) 0. (* Expected result: {0, 0, 0} *)\nCompute (ANetVfToANetLf complexExampleNet) 1. (* Expected result: {1, 1, 2} *)\nCompute (ANetVfToANetLf complexExampleNet) 2. (* Expected result: {2, 4, 0} *)\nCompute (ANetVfToANetLf complexExampleNet) 3. (* Expected result: {3, 0, 5} *)\nCompute (ANetVfToANetLf complexExampleNet) 4. (* Expected result: {4, 1, 1} *)\nCompute (ANetVfToANetLf complexExampleNet) 5. (* Expected result: {0, 0, 0} *)\n\n(* Associative network of nested ordered pairs *)\nDefinition testPairsNet : ANetLf :=\n  fun id => match id with\n  | 0 => {5, 0, 8}\n  | 1 => {7, 1, 2}\n  | 2 => {2, 4, 5}\n  | 3 => {3, 1, 5}\n  | 4 => {4, 2, 1}\n  | S _ => {0, 0, 0}\n  end.\n\n(* Converted associative network of nested ordered pairs into a three-dimensional associative network (dimensions must match) *)\nDefinition testTuplesNet : ANetVf 3 :=\n  ANetLfToANetVf testPairsNet.\n\n(* Computing the values of the converted function of the associative network of nested ordered pairs *)\nCompute testTuplesNet 0.   (* Expected result: [5; 0; 8] *)\nCompute testTuplesNet 1.   (* Expected result: [7; 1; 2] *)\nCompute testTuplesNet 2.   (* Expected result: [2; 4; 5] *)\nCompute testTuplesNet 3.   (* Expected result: [3; 1; 5] *)\nCompute testTuplesNet 4.   (* Expected result: [4; 2; 1] *)\nCompute testTuplesNet 5.   (* Expected result: [0; 0; 0] *)\n\n(* Conversion of nested ordered pairs into the associative network of duplets *)\nCompute NPToANetDl { 121, 21, 1343 }.\n(* Should return: {(121, 1), (21, 2), (1343, 2)} *)\n\n(* Adding nested ordered pairs to the associative network of duplets *)\nCompute AddNPToANetDl {(121, 1), (21, 2), (1343, 2)} {12, 23, 34}. \n(* Expected result: {(121, 1), (21, 2), (1343, 2), (12, 4), (23, 5), (34, 5)} *)\n\n(* Conversion of the associative network of duplets into nested ordered pairs *)\nCompute ANetDlToNP {(121, 1), (21, 2), (1343, 2)}. \n(* Expected result: {121, 21, 1343} *)\n  \nCompute ANetDlToNP {(121, 1), (21, 2), (1343, 2), (12, 4), (23, 5), (34, 5)}. \n(* Expected result: {121, 21, 1343} *)\n\n(* Reading nested ordered pairs from the associative network of duplets by the duplet index (start of the nested ordered pair) *)\nCompute ANetDl_readNP {(121, 1), (21, 2), (1343, 2), (12, 4), (23, 5), (34, 5)} 0.\n(* Expected result: {121, 21, 1343} *)\n\nCompute ANetDl_readNP {(121, 1), (21, 2), (1343, 2), (12, 4), (23, 5), (34, 5)} 3.\n(* Expected result: {12, 23, 34} *)\n\n(* Defining an associative network of nested ordered pairs *)\nDefinition test_anetl := { {121, 21, 1343}, {12, 23}, {34}, {121, 21, 1343}, {12, 23}, {34} }.\n\n(* Converted associative network of nested ordered pairs into the associative network of duplets *)\nDefinition test_anetd := ANetLlToANetDl test_anetl.\n\n(* Computing the converted associative network of nested ordered pairs into the associative network of duplets *)\nCompute test_anetd.\n(* Expected result:\n {(121, 1), (21, 2), (1343, 2),\n  (12, 4), (23, 4),\n  (34, 5),\n  (121, 7), (21, 8), (1343, 8),\n  (12, 10), (23, 10),\n  (34, 11)} *)\n\n(* Converting the associative network of nested ordered pairs into the associative network of duplets and back into test_anetl *) \nCompute ANetDlToANetLl test_anetd.\n(* Expected result:\n  {{121, 21, 1343}, {12, 23}, {34}, {121, 21, 1343}, {12, 23}, {34}}  *)\n\n(* Computing the offset of nested ordered pairs in the associative network of duplets by their ordinal number *)\nCompute ANetDl_offsetNP test_anetd 0.   (* Expected result: 0 *)\nCompute ANetDl_offsetNP test_anetd 1.   (* Expected result: 3 *)\nCompute ANetDl_offsetNP test_anetd 2.   (* Expected result: 5 *)\nCompute ANetDl_offsetNP test_anetd 3.   (* Expected result: 6 *)\nCompute ANetDl_offsetNP test_anetd 4.   (* Expected result: 9 *)\nCompute ANetDl_offsetNP test_anetd 5.   (* Expected result: 11 *)\nCompute ANetDl_offsetNP test_anetd 6.   (* Expected result: 12 *)\nCompute ANetDl_offsetNP test_anetd 7.   (* Expected result: 12 *)\n\n(* Defining a three-dimensional associative network as a sequence of vectors of length 3 *)\nDefinition test_anetv : ANetVl 3 :=\n  { [0; 0; 0], [1; 1; 2], [2; 4; 0], [3; 0; 5], [4; 1; 1], [0; 0; 0] }.\n\n(* Converted three-dimensional associative network into the associative network of duplets via the associative network of nested ordered pairs *)\nDefinition test_anetdl : ANetDl := ANetVlToANetDl test_anetv.\n\n(* Computing the three-dimensional associative network converted into the associative network of duplets via the associative network of nested ordered pairs *)\nCompute test_anetdl.\n(* Expected result:\n{ (0, 1), (0, 2), (0, 2),\n  (1, 4), (1, 5), (2, 5),\n  (2, 7), (4, 8), (0, 8),\n  (3, 10), (0, 11), (5, 11),\n  (4, 13), (1, 14), (1, 14),\n  (0, 16), (0, 17), (0, 17)}  *)\n\n(* Converted three-dimensional associative network into the associative network of duplets via the associative network of nested ordered pairs and then back into a three-dimensional associative network *)\nDefinition result_TuplesNet : ANetVl 3 :=\n  ANetLlToANetVl (ANetDlToANetLl test_anetdl).\n\n(* Final check of the equivalence of associative networks *)\nCompute result_TuplesNet.\n(* Expected result:\n  { [0; 0; 0], [1; 1; 2], [2; 4; 0], [3; 0; 5], [4; 1; 1], [0; 0; 0] } *)\n```\n\n## Practical implementation\n\nThere are several practical implementations: [Deep](http://github.com/deep-foundation/), [LinksPlatform](https://github.com/linksplatform) and [the model of relations](https://github.com/netkeep80/jsonRVM).\n\n### Deep\n\n[Deep](http://github.com/deep-foundation/) is a system based on the links theory. In links theory, links can be used to represent any data or knowledge, as well as to perform programming. Deep is built around this philosophy: in Deep, everything is a link. However, if we divide these links into two categories, we have data itself and behavior. Behavior — represented by code in Deep — is stored in the associative store as links, and for execution it is passed to a Docker container of the corresponding programming language, where it runs in isolation and safely. All communication between different parts of the code is carried out through links in the store (database), making the database a universal data-based API (in contrast to the traditional practice of calling functions and methods). At present, PostgreSQL is used as the associative store in Deep, which will later be replaced by a data engine based on doublets and triplets from LinksPlatform.\n\nDeep makes all software on the planet interoperable by representing all its parts as links. It is also possible to store any data and code together, linking events or actions on various types of associations with the corresponding code that is executed to handle those events. Each handler can retrieve the necessary links from the associative store and insert/update/delete links in it, which may trigger further cascade execution of handlers.\n\nThe `links` table in Deep’s PostgreSQL database contains records that can be interpreted as links. They have columns such as `id`, `type_id`, `from_id`, and `to_id`. The links types help the developer of associative packages predefine the semantics of the relationships between various elements, ensuring an unambiguous understanding of links by both people and code in the associative packages. In addition to the `links` table, the system also includes tables named `numbers`, `strings`, and `objects` for storing numeric, string, and JSON values, respectively. Each link can be associated with only one value. This is temporary solution, that is used until Deep will not migrate to use of LinksPlatform as a database engine. Once migration is complete all these seemingly basic types will be built from the ground up using only links. It will allow to use deduplication (that arises as a consequence of the links theory) and deep understanding of values inner structure. Also it is planned to add indexing of such complex values represented by links, to improve performance to make it as fast or faster than current PostgreSQL implementation.\n\n### LinksPlatfrom\n\n[LinksPlatfrom](https://github.com/linksplatform) is a cross-platform, multi-language framework aimed at providing a low-level implementation of associativity in the form of a database engine constructor. For example, at present we have a [benchmark](https://github.com/linksplatform/Comparisons.PostgreSQLVSDoublets) that compares the implementation of doublets in PostgreSQL with a similar implementation in pure Rust/C++; the leading implementation in Rust outperforms PostgreSQL by ![1746 \\dots 15745](https://habrastorage.org/getpro/habr/upload_files/cbd/c7b/80c/cbdc7b80c67db3247748301c54b2dfb0.svg) times in write operations and ![100 \\dots 9694](https://habrastorage.org/getpro/habr/upload_files/eee/c96/77c/eeec9677cc65db3059e2dc0a2915ebab.svg) times in read operations.\n\n### The model of relations\n\n[The model of relations](https://github.com/netkeep80/jsonRVM) is a meta-programming language based on representing a program as a three-dimensional associative network. The model of relations adheres to entity-oriented programming, where the entity is used as the single fundamental concept — that is, it assumes that everything is an entity and there is nothing besides entities.\n\nIn the model of relations, an entity, depending on its internal constitutive principle, can be either a structure (object) or a function (method). Unlike the well-known ER model, which uses two basic concepts — entity and relation — to represent the database schema, in the model of relations the entity and the relation are essentially the same. This representation allows one to describe not only the external relationships of an entity, but also its internal model — the model of relationships.\n\nAn entity, in its internal principle, is triune (threefold, consisting of three elements) because it is a synthesis of three aspects (qualities) of other entities (or of itself).\n\n[jsonRVM](https://github.com/netkeep80/jsonRVM) is a multithreaded virtual machine for executing the JSON projection of the model of relations. The model of relations, when represented as JSON, allows programs to be written directly in JSON. This representation is a hybrid of data and code segments and makes it easy to deserialize/execute/serialize the projection of the model of relations, as well as to use JSON editors for programming. In the execution process of the model of relations, the meta-program can not only process data but also generate multithreaded programs and meta-programs, and either execute them immediately or export them as JSON.\n\n## Conclusion\n\nIn this article, we examined the mathematical foundations of relational algebra and graph theory, and presented the definitions of the links theory in terms of set theory and its projection into type theory. We also defined a set of functions and lemmas necessary for proving the possibility of an equivalent conversion from any vector/sequence into nested doublet-links and back. This means that only one formula is sufficient to represent any possible type of information:\n\n> ![L \\to L^2](https://habrastorage.org/getpro/habr/upload_files/42d/52f/71e/42d52f71e0454feb23d2d4d6773ab933.svg)\n\nThus, this forms the basis for testing the hypothesis that any other data structure can be represented by doublet-links. In other words, doublet-links are sufficient to represent any tables, graphs, strings, arrays, lists, numbers, sound, images, videos, and much more.  \n  \nAnother consequence of this proof is that we can represent tape of Turing Machine using only doublet‑links. That means links can be as powerful as a Turing Machine in its storage capacity. Meaning we can use links for all use cases there Turing Machine is used. But there is no need to try to fit data into zeroes and ones, no need to puzzle about that. Because in links the “alphabet” is essentially is unlimited and you can add any number of links, assign to them any meaning you need and link or connect them together in any way you need. Usually it means that your concept, object or thing from the real or abstract world will be mapped 1 to 1 into links or as close to original as possible, which is sometimes not possible with traditional methods.\n\nWe continue to make progress in synchronizing meaning between our three projects and among the people in our associative community. These projects are designed to bring associativity into the world and make it useful for humanity. This article is another iteration of our discussion, allowing us to agree on a unified meaning of words and terms within the general associative theory. We believe this theory can become a meta-language on which is already used by people and machines to communicate.\n\nWith each further refinement, we will be one step closer to speaking a common language and making this idea more understandable to everyone. This theory will also be useful for various optimizations in the associative implementations under development, and in the future, for the design of associative chips (or coprocessors) to accelerate operations on data represented as links.\n\n### Plans for the future\n\nThis article has demonstrated only a small part of all the developments in the links theory that have accumulated over several years of work and research. In subsequent articles, other projections of the links theory will gradually be revealed, in terms of other theories such as relational algebra, graph theory, and also in terms of type theory without using set theory directly, as well as an analysis of the differences from [Simon Williams’ associative model of data](https://web.archive.org/web/20181219134621/http://sentences.com/docs/amd.pdf) [\\[3\\]](https://web.archive.org/web/20181219134621/http://sentences.com/docs/amd.pdf).  \n  \nWe also plan to project the links theory to into itself, showing that it can be used as meta-theory. That will also open a door for projecting set theory and type theory into the links theory, meaning we now complete the cycle of definition (the links theory is defined in the set theory which itself can be defined in the links theory). We also be able to compare set theory, type theory, graph theory, relational algebra and links theory, that will help us to test the equivalence of these theory or at least get the precise bijective function to convert between them.  \n  \nThere are also plans to present a clear and unified terminology of the links theory, its basic postulates, aspects and so on. The current progress in developing the theory can be observed in the [deep-theory repository](https://github.com/deep-foundation/deep-theory).  \n  \nTo get updates, we recommend subscribing to the [Deep.Foundation blog](https://habr.com/ru/companies/deepfoundation) here or checking out our [work on GitHub](https://github.com/deep-foundation) now, or directly contacting us at [our Telegram public chat](https://t.me/unilinkness) (especially if you’re afraid of getting downvoted in the comments).  \n  \nWe welcome any feedback you may have, whether on Habr, GitHub, or Telegram. You can also participate in the development of the theory or help accelerate its progress by engaging with us in any way.\n\n### CLI demo\n\nNow you can get the sense of how associative theory works using our [CLI demo tool](https://github.com/link-foundation/link-cli), that is build up on [links notation](https://github.com/linksplatform/Protocols.Lino) and [Doublet-links storage](https://github.com/linksplatform/Data.Doublets) from [LinksPlatform](https://github.com/linksplatform) project. [Links notation](https://github.com/linksplatform/Protocols.Lino) is a language for data expressed in the links and references only. [Doublets](https://github.com/linksplatform/Data.Doublets) are a database engine written in C# from the ground up to support only associative storage and transformations.  \n  \nIn this demo we build up on links notation to create a dialect that is able to describe single universal operation - substitution. As with unification of data types, it is also possible to unify creation, read, update and deletion into single substitution operation. That is similar to the only operation from [Markov algorithm](https://en.wikipedia.org/wiki/Markov_algorithm), which is proven to be [Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness#:~:text=13%20External%20links-,Non%2Dmathematical%20usage,purpose%20computer%20or%20computer%20language.).\n\n![Figure 11. In this image you can see creation of two links (1: 1 1) and (2: 2 2); update of first link to (1: 1 2); update/substitution using variables to swap sources and targets of each link; and a deletion of all links using (* *) pattern.](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2b3/461/555/2b34615551356a195304f0af610858b8.png \"Figure 11. In this image you can see creation of two links (1: 1 1) and (2: 2 2); update of first link to (1: 1 2); update/substitution using variables to swap sources and targets of each link; and a deletion of all links using (* *) pattern.\")\n\n**Figure 11.** In this image you can see creation of two links `(1: 1 1)` and `(2: 2 2);` update of first link to `(1: 1 2)`; update/substitution using variables to swap sources and targets of each link; and a deletion of all links using `(* *)` pattern.\n\n### Visual demos\n\n![Figure 12. Link blueprint designer build on top of a configurable spline: konard.github.io/links-visuals/blueprint.html (move control points of spline that represents the link)](https://habrastorage.org/r/w1560/getpro/habr/upload_files/07f/3c0/c00/07f3c0c003624000b56c731ae349034c.png \"Figure 12. Link blueprint designer build on top of a configurable spline: konard.github.io/links-visuals/blueprint.html (move control points of spline that represents the link)\")\n\n**Figure 12.** Link blueprint designer build on top of a configurable spline: [konard.github.io/links-visuals/blueprint.html](http://konard.github.io/links-visuals/blueprint.html) (move control points of spline that represents the link)\n\n![Figure 13. H-tree like fractal build using links represented by straight arrows: konard.github.io/links-visuals/H-fractal.html (click at any place to iterate the fractal)](https://habrastorage.org/r/w1560/getpro/habr/upload_files/169/e83/811/169e8381146678c2e1dbab896d3e2569.jpg \"Figure 13. H-tree like fractal build using links represented by straight arrows: konard.github.io/links-visuals/H-fractal.html (click at any place to iterate the fractal)\")\n\n**Figure 13.** [H-tree](https://en.wikipedia.org/wiki/H_tree) like fractal build using links represented by straight arrows: [konard.github.io/links-visuals/H-fractal.html](https://konard.github.io/links-visuals/H-fractal.html) (click at any place to iterate the fractal)\n\n### P.S.\n\nThis and previous articles will be updated as the links theory develops and expands over the next 6 months.\n\n### P.S.S.\n\nIf you have become a fan of the links theory, we invite you to spread this formula as a meme-virus on social media.\n\nUsing Unicode symbols:\n\n> L ↦ L²\n\nUsing LaTeX:\n\n> L \\\\to L^2\n\nWhich is rendered as SVG (clickable):\n\n> ![L \\to L^2](https://habrastorage.org/getpro/habr/upload_files/42d/52f/71e/42d52f71e0454feb23d2d4d6773ab933.svg)\n\n### References\n\n1.  Edgar F. Codd, IBM Research Laboratory, San Jose, California, June 1970, [“Relational Model of Data for Large Shared Data Banks.”, paragraph 1.3., page 379](https://dl.acm.org/doi/abs/10.1145/362384.362685)\n    \n2.  Bender, Edward A.; Williamson, S. Gill (2010). [“Lists, Decisions and Graphs. With an Introduction to Probability.”, section 2, definition 6, page 161](https://books.google.com/books?id=vaXv_yhefG8C)\n    \n3.  Simon Williams, Great Britain (1988), [The Associative Model Of Data](https://web.archive.org/web/20181219134621/http://sentences.com/docs/amd.pdf)\n    \n4.  Homan, J. V., & Kovacs, P. J. (2009). [A Comparison of the Relational Database Model and the Associative Database Model](https://www.researchgate.net/publication/255670856_A_COMPARISON_OF_THE_RELATIONAL_DATABASE_MODEL_AND_THE_ASSOCIATIVE_DATABASE_MODEL). Issues in Information Systems, X(1), 208.\n    \n\nTags:\n\n-   [metatheory](/en/search/?target_type=posts&order=relevance&q=[metatheory])\n-   [links theory](/en/search/?target_type=posts&order=relevance&q=[links+theory])\n-   [relational theory](/en/search/?target_type=posts&order=relevance&q=[relational+theory])\n-   [associative theory](/en/search/?target_type=posts&order=relevance&q=[associative+theory])\n-   [math](/en/search/?target_type=posts&order=relevance&q=[math])\n-   [set theory](/en/search/?target_type=posts&order=relevance&q=[set+theory])\n-   [type theory](/en/search/?target_type=posts&order=relevance&q=[type+theory])\n-   [graph theory](/en/search/?target_type=posts&order=relevance&q=[graph+theory])\n-   [relational algebra](/en/search/?target_type=posts&order=relevance&q=[relational+algebra])\n-   [associative model of data](/en/search/?target_type=posts&order=relevance&q=[associative+model+of+data])\n\nHubs:\n\n-   [Data Engineering](/en/hubs/data_engineering/)\n-   [Open source](/en/hubs/open_source/)\n-   [Mathematics](/en/hubs/maths/)\n-   [Abnormal programming](/en/hubs/crazydev/)\n-   [Programming](/en/hubs/programming/)\n\nTotal votes 10: ↑10 and ↓0+10\n\nAdd to bookmarks5\n\n[Comments2](/en/articles/895896/comments/)\n\n[\n\n![](//habrastorage.org/getpro/habr/avatars/faa/6f7/0a5/faa6f70a548befa99b28025c5dfcdd6d.jpg)\n\n](/en/users/Konard/)\n\n11\n\nKarma\n\n0\n\nGlobal rating\n\nКонстантин Дьяченко [@Konard](/en/users/Konard/)\n\nВоплощающий ассоциативность\n\nFollow\n\nSend message\n\n[Comments Comments 2](/en/articles/895896/comments/)\n\n## Articles\n\nTop of the daySimilar articles\n\nShow the best of all time\n\nYour account\n\n-   [Log in](/kek/v1/auth/habrahabr/?back=/en/articles/895896/&hl=en)\n-   [Sign up](/kek/v1/auth/habrahabr-register/?back=/en/articles/895896/&hl=en)\n\nSections\n\n-   [Articles](/en/articles/)\n-   [News](/en/news/)\n-   [Hubs](/en/hubs/)\n-   [Authors](/en/users/)\n-   [Sandbox](/en/sandbox/)\n\nInformation\n\n-   [How it works](/en/docs/help/)\n-   [For authors](/en/docs/authors/codex/)\n-   [For companies](/en/docs/companies/corpblogs/)\n-   [Documents](/en/docs/docs/transparency/)\n-   [Agreement](https://account.habr.com/info/agreement/?hl=en_US)\n-   [Confidential](https://account.habr.com/info/confidential/?hl=en_US)\n\nServices\n\n-   [Corporate blogs](https://company.habr.com/en/corporate-blogs/)\n-   [Advertising](https://company.habr.com/en/advertising/)\n-   [Native advertising](https://company.habr.com/en/native-special/)\n-   [Education programs](https://company.habr.com/en/education-programs/)\n-   [Startups](https://company.habr.com/en/hello-startup/)\n\n[Facebook](https://www.facebook.com/habr.eng)[Twitter](https://twitter.com/habr_eng)[Telegram](https://t.me/habr_eng)\n\nLanguage settings[Support](/en/feedback/)\n\n© 2006–2025, [Habr](https://company.habr.com/en/)",
      "title": "https://habr.com/en/articles/895896 (text/html; charset=utf-8)",
      "metadata": {},
      "time": {
        "start": 1763624903656,
        "end": 1763624905143
      }
    }
  }
}
{
  "type": "step_finish",
  "timestamp": 1763624905147,
  "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
  "part": {
    "id": "prt_aa03c69ba001g6etNG9ZHyiv4o",
    "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
    "messageID": "msg_aa03c47ca001RyPgbaOc92qMzv",
    "type": "step-finish",
    "reason": "tool-calls",
    "cost": 0,
    "tokens": {
      "input": 8273,
      "output": 45,
      "reasoning": 598,
      "cache": {
        "read": 2432,
        "write": 0
      }
    }
  }
}
{
  "type": "step_start",
  "timestamp": 1763624906829,
  "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
  "part": {
    "id": "prt_aa03c704a001JJqDhVuCHqynke",
    "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
    "messageID": "msg_aa03c69be001ktVSY6fJRmUhcq",
    "type": "step-start"
  }
}
{
  "type": "text",
  "timestamp": 1763624908801,
  "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
  "part": {
    "id": "prt_aa03c7721001fQmK6tYhPKsvc3",
    "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
    "messageID": "msg_aa03c69be001ktVSY6fJRmUhcq",
    "type": "text",
    "text": "> This article contains many letters, but it can be represented using just 4 symbols from set theory: L → L² Everything else follows from them.",
    "time": {
      "start": 1763624908800,
      "end": 1763624908800
    }
  }
}
{
  "type": "step_finish",
  "timestamp": 1763624908803,
  "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
  "part": {
    "id": "prt_aa03c7802001albuDJn9aAVX66",
    "sessionID": "ses_55fc3b873ffepo4PZhujJkAD0H",
    "messageID": "msg_aa03c69be001ktVSY6fJRmUhcq",
    "type": "step-finish",
    "reason": "stop",
    "cost": 0,
    "tokens": {
      "input": 21161,
      "output": 31,
      "reasoning": 205,
      "cache": {
        "read": 11328,
        "write": 0
      }
    }
  }
}
konard@MacBook-Pro-Konstantin ~ % 
```